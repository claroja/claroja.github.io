# Redis与缓存

## 最佳实践


### 🔒问题总结

1. (6分)填写Redis命令，基于ZSet。(2024上)

    - 存入秒杀的分数命令：ZADD
    - 获取分数范围的命令：ZRANGE
    - 获取分数：ZSCORE

2. 该系统采用了 Redis 来实现某些特定功能(如当前热销药品排名等)，同时将药品关系数据放到内存以提高商品查询的性能，但必然会造成 Redis 和 MySQL 的数据实时同步问题。
    1. Redis 的数据类型包括 String、Hash、List、Set 和 ZSet 等，请说明实现当前热销药品排名的功能应该选择使用哪种数据类型。(2021下)

        选择ZSet数据类型。

        - String：基本类型。可用于缓存层或计数器，如视频播放量、文章浏览量等。
        - Hash：代替string类型，节省空间。描述用户信息较为方便。
        - Set：无序集合，每个值不能重复。可用于去重、抽奖、初始化用户池等。 
        - List：双向链表结构，可以模拟栈、队列等形式。可用于回复评论、点赞。 
        - ZSet：有序集合、每个元素有一个分数。如首页推荐10个最热门的帖子。

    2. 请用 200 字以内的文字解释说明解决 Redis 和 MySQL 数据实时同步问题的常见方案。(2021下) 


        1. 引用Mysql的事务，因为事务有一致性保证，事务提交成功后再更新缓存；
        2. 在缓存里面引用一些访问控制位，数据库数据变化后，同步变更对应的访问控制位，然后从缓存查询时，率先判断该访问控制位，有变化就从数据库查，无变化直接从缓存返回数据；
        3. 通过数据库中间件产品保证缓存和数据库数据时时同步。

3. 某初创企业的主营业务是为用户提供高度个性化的商品订购业务，其业务系统支持PC端、手机APP等多种访问方式。系统上线后受到用户普遍欢迎，在线用户数和订单数量迅速增长，原有的关系数据库服务器不能满足高速并发的业务要求。

    为了减轻数据库服务器的压力，该企业采用了分布式缓存系统，将应用系统经常使用的数据放置在内存，降低对数据库服务器的查询请求，提高了系统性能。在使用缓存系统的过程中，企业碰到了一系列技术问题。

    1. (11分)该系统使用过程中，由于同样的数据分别存在于数据库和缓存系统中，必然会造成数据同步或数据不一致性的问题。该企业团队为解决这个问题，提出了如下解决思路：

    应用程序读数据时，首先读缓存，当该数据不在缓存时，再读取数据库；应用程序写数据时，先写缓存，成功后再写数据库；或者先写数据库，再写缓存。

    王工认为该解决思路并未解决数据同步或数据不一致性的问题，请用100字以内的文字解释其原因。

    王工给出了一种可以解决该问题的数据读写步骤如下：

    读数据操作的基本步骤：

    2. 根据key读缓存；
    3. 读取成功则直接返回；
    4. 若key不在缓存中时，根据key(a) ；
    5. 读取成功后，(b) ；
    6. 成功返回。

    写数据操作的基本步骤：

    7. 根据key值写(c) ；
    8. 成功后(d) ；
    9. 成功返回。

    请填写完善上述步骤中(a)~(d)处的空白内容。(2019下)

    在高并发条件下存在不同线程间网络延迟不同的情况，且缓存和数据库数据不同写入请求的速度也存在差异，并且缓存和数据库删除和写入均存在失败的可能性，这些会导致解决思路无法解决数据同步和不一致性问题。
    (a)读数据库，
    (b)写缓存
    (c)数据库
    (d)更新缓存key值/删除缓存key值/使缓存key值失效。

    2. (8分)缓存系统一般以key/value形式存储数据，在系统运维中发现，部分针对缓存的查询，未在缓存系统中找到对应的key，从而引发了大量对数据库服务器的查询请求，最严重时甚至导致了数据库服务器的宕机。

        经过运维人员的深入分析，发现存在两种情况：

        (1)用户请求的key值在系统中不存在时，会查询数据库系统，加大了数据库服务器的压力；

        (2)系统运行期间，发生了黑客攻击，以大量系统不存在的随机key发起了查询请求，从而导致了数据库服务器的宕机。

        经过研究，研发团队决定，当在数据库中也未查找到该key时，在缓存系统中为key设置空值，防止对数据库服务器发起重复查询。

        请用100字以内文字说明该设置空值方案存在的问题，并给出解决思路。(2019下)

        存在问题：空值缓存需要更多的键，浪费内存空间。
        解决思路：查询缓存前，对key值进行过滤，只允许系统中存在的key进行后续操作(例如采用key的bitmap进行过滤)。

    3. (6分)缓存系统中的key一般会存在有效期，超过有效期则key失效；有时也会根据LRU算法将某些key移出内存。当应用软件查询key时，如key失效或不在内存，会重新读取数据库，并更新缓存中的key。

        运维团队发现在某些情况下，若大量的key设置了相同的失效时间，导致缓存在同一时刻众多key同时失效，或者瞬间产生对缓存系统不存在key的大量访问，或者缓存系统重启等原因，都会造成数据库服务器请求瞬时爆量，引起大量缓存更新操作，导致整个系统性能急剧下降，进而造成整个系统崩溃。

        请用100字以内文字，给出解决该问题的两种不同思路。 (2019下)

        1. 搭建高可用Redis集群，正式部署前提前进行数据预热，在大并发访问前加载缓存键并尽量均匀分布缓存过期时间；
        2. 将热点数据设置为永不过期，开启Redis的持久化功能，当Redis启动时，从磁盘恢复数据到缓存中。

4. 某企业是为城市高端用户提供高品质蔬菜生鲜服务的初创企业，创业初期为快速开展业务，该企业采用轻量级的开发架构(脚本语言 + 关系型数据库)研制了一套业务系统。业务开展后受到用户普遍欢迎，用户数和业务数量迅速增长，原有的数据库服务器已不能满足高度并发的业务要求。为此，该企业成立了专门的研发团队来解决该问题。

    张工建议重新开发整个系统，采用新的服务器和数据架构，解决当前问题的同时为日后的扩展提供支持。但是，李工认为张工的方案开发周期过长，投入过大，当前应该在改动尽量小的前提下解决该问题。李工认为访问量很大的只是部分数据，建议采用缓存工具 MemCache 来减轻数据库服务器的压力，这样开发量小，开发周期短，比较适合初创公司，同时将来也可以通过集群进行扩展。然而，刘工又认为李工的方案中存在数据可靠性和一致性问题，在宕机时容易丢失交易数据，建议采用 Redis 来解决问题。经过充分讨论，该公司最终决定采用刘工的方案。

    1. (9 分)在李工和刘工的方案中，均采用分布式数据库缓存技术来解决问题。请用 100 字以内的文字解释说明分布式数据库缓存的基本概念。(2018下)

    表 4 - 1 中对 MemCache 和 Redis 两种工具的优缺点进行了比较，请补充完善表 4 - 1 中的空(1)~(6)。

    |  | Memcache | Redis |
    | ---- | ---- | ---- |
    | 数据类型 | 简单 key/value 结构 | (1) |
    | 持久性 | (2) | 支持 |
    | 分布式存储 | (3) | 多种方式，主从、Sentinel、Cluster 等 |
    | 多线程支持 | 支持 | (4) |
    | 内存管理 | (5) | 无 |
    | 事务支持 | (6) | 有限支持 |

    分布式数据库缓存指的是在高并发环境下，为了减轻数据库压力和提高系统响应时间，在数据库系统和应用系统之间增加的独立缓存系统。
    (1)丰富/多种数据结构；
    (2)不支持；
    (3)客户端哈希分片/一致性哈希；
    (4)不支持；
    (5)私有内存池/内存池；
    (6)不支持。

    2. (8 分)刘工认为李工的方案存在数据可靠性和一致性的问题，请用 100 字以内的文字解释说明。
    为避免数据可靠性和一致性的问题，刘工的方案采用 Redis 作为数据库缓存，请用 200 字以内的文字说明基本的 Redis 与原有关系数据库的数据同步方案。

        李工采用的方案中，采用 MemCache 作为缓存系统，但 MemCache 无法进行持久化，数据不能备份，只能用于缓存使用，数据全部存在于内存，一旦重启数据会全部丢失。刘工的方案中，采用 Redis 作为数据库缓存，解决了该问题。

        刘工的方案中，保留原关系数据库，将 Redis 仅作为缓存，即热点数据缓存存 Redis 中，核心业务的结构化数据存储在原关系数据库中。需要解决热点数据在原关系数据库和 Redis 的数据同步问题，由于 Redis 只作为缓存，因此给出原关系数据库到 Redis 的同步方案即可。该方案的基本操作如下。

        1. 读操作。读缓存 Redis，如果数据不存在，从原关系数据库中读数据，并将读取后的数据值写入到 Redis；
        2. 写操作。写原关系数据库，写成功后，更新或者失效掉缓存 Redis 中的值。

    3. (8 分)请用 300 字以内的文字，说明 Redis 分布式存储的两种常见方案，并解释说明 Redis 集群切片的几种常见方式。

        Redis 分布式存储的常见方案有：
        1. 主从(Master/Slave)模式；
        2. 哨兵(Sentinel)模式
        3. 集群(Cluster)模式。

        Redis 集群切片的常见方式有：
        4. 客户端实现分片。分区逻辑在客户端实现，采用一致性哈希来决定 Redis 节点。
        5. 中间件实现分片。在应用软件和 Redis 中间，例如 Twemproxy、Codis 等，由中间件实现服务到后台 Redis 节点的路由分派。
        6. 客户端服务端协作分片。Redis Cluster模式，客户端可采用一致性哈希，服务端提供错误节点的重定向服务。

1. 某互联网文化发展公司因业务发展，需要建立网上社区平台，为用户提供一个对网络文化产品(如互联网小说、电影、漫画等)进行评论、交流的平台。该平台的部分功能如下：

    (a)用户帖子的评论计数器；
    (b)支持粉丝列表功能； 
    (c)支持标签管理；
    (d)支持共同好友功能等；
    (e)提供排名功能，如当天最热前10名帖子排名、热搜榜前5排名等；
    (f)用户信息的结构化存储；
    (g)提供好友信息的发布/订阅功能。

    该系统在性能上需要考虑高性能、高并发，以支持大量用户的同时访问。开发团队经过综合考虑，在数据管理上决定采用Redis+数据库(缓存+数据库)的解决方案。

    1. (10分)Redis支持丰富的数据类型，并能够提供一些常见功能需求的解决方案。请选择题干描述的(a)~(g)功能选项，填入表4 - 1中(1)~(5)的空白处。 (2020下)

        |数据类型|存储的值|可实现的业务功能|
        | ---- | ---- | ---- |
        |STRING|字符串、整数或浮点数|(1)|
        |LIST|列表|(2)|
        |SET|无序集合|(3)|
        |HASH|包括键值对的无序散列表|(4)|
        |ZSET|有序集合|(5)| 

        (1)a(2)b、g(3)c、d(4)f(5)e

        - string：最基本的数据类型，二进制安全的字符串，可以包含任何数据(图片或序列化对象)，最大512M。应用场景：缓存、计数器、共享用户session、分布式锁、分布式系统的全局序列号等；
        - list：按照添加顺序保持顺序的字符串列表，应用场景：栈、队列、阻塞队列、最新列表等；
        - set：无序的字符串集合，不存在重复的元素，应用场景：用户标签、好友/关注/粉丝/感兴趣的人集合、随机展示、黑/白名单、抽奖小程序等；
        - sortedset：已排序的字符串集合，不允许重复，应用场景：标签、共同好友/喜好、统计网站的独立IP、统计点赞/取消点赞、排行榜； 
        - hash：key-value对的一种集合，特别适合用于存储对象，应用场景：存储对象、电商购物车等； 
        - bitmap：更细化的一种操作，以bit为单位； 
        - hyperloglog：基于概率的数据结构。为V2.8.9新增； 
        - geo：地理位置信息储存起来，并对这些信息进行操作，为#V3.2新增； 
        - stream：流，相当于消息队列的topic，为V5.0新增。 

    2. (7分)该网上社区平台需要为用户提供7×24小时的不间断服务。同时在系统出现宕机等故障时，能在最短时间内通过重启等方式重新建立服务。为此，开发团队选择了Redis持久化支持。Redis有两种持久化方式，分别是RDB(Redis Data Base)持久化方式和AOF(Append Only File)持久化方式。开发团队最终选择了RDB方式。 请用200字以内的文字，从磁盘更新频率、数据安全、数据一致性、重启性能和数据文件大小五个方面比较两种方式，并简要说明开发团队选择RDB的原因。(2020下)

        1. 磁盘更新频率：RDB更新频率比AOF低。
        2. 数据安全：AOF可以保证数据不丢失，比RDB更安全。 
        3. 数据一致性：RDB间隔一段时间存储，可能发生数据丢失和不一致；AOF通过append模式写文件，即使发生服务器宕机，也可通过redis-check-aof工具解决数据一致性问题。 
        4. 重启性能：RDB比AOF更高。 
        5. 数据文件大小：RDB文件比AOF小。

        由于RDB数据恢复更快，能在最短时间内重新建立服务，因此团队最终选择了RDB。 

    3. (8分)缓存中存储当前的热点数据，Redis为每个KEY值都设置了过期时间，以提高缓存命中率。为了清除非热点数据，Redis选择“定期删除+惰性删除”策略。如果该策略失效，Redis内存使用率会越来越高，一般应采用内存淘汰机制来解决。请用100字以内的文字简要描述该策略的失效场景，并给出三种内存淘汰机制。 (2020下)

        1. 定期删除策略: 每隔一段时间，主动遍历部分过期键并删除其中已过期的键。
        2. 惰性删除策略: 不主动删除过期键，而是在访问键时(如读取、修改操作)，临时检查键是否过期，若过期则删除并返回空结果。

        有两种场景：

        1. 不管定期删除还是惰性删除，都是一种不完全精确的删除策略，始终还是会存在已经过期的key无法被删除的场景；
        2. 内存被挤满了。

        Redis内存淘汰机制：

        - volatile-lru，针对设置了过期时间的key，使用LRU(Least Recently Used，最近很少使用)算法进行淘汰。
        - volatile-lfu，针对设置了过期时间的key，使用LRU(Least Frequently Used，最不经常使用)算法进行淘汰。 
        - volatile-random，从所有设置了过期时间的key中使用随机淘汰的方式进行淘汰。 
        - volatile-ttl，针对设置了过期时间的key，越早过期的越先被淘汰。 
        - allkeys-lru，针对所有key使用LRU算法进行淘汰。 
        - allkeys-lfu，针对所有key使用LRU算法进行淘汰。 
        - allkeys-random，针对所有的key使用随机淘汰机制进行淘汰。 
        - noeviction，不会淘汰任何数据，当使用的内存空间超过max memory值时，再有写请求来时返回错误。 


### 考察点

见数据工程/redis

### 考察问

见数据工程/redis





## 参考

1. https://www.hangge.com/blog/cache/detail_3444.html
2. https://www.cnblogs.com/xiaolincoding/p/16370783.html
3. https://zhuanlan.zhihu.com/p/686875689
4. https://www.cnblogs.com/xiaokang-coding/articles/18531836
5. https://www.cnblogs.com/gabin/p/13547417.html
6. https://www.cnblogs.com/gabin/p/13547417.html