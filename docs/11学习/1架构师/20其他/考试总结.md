### 考察点

- 💛安全模型设计目的: ✨其他是`完整`性, BLP和Chinese Wall是`机密`性
    - `完整性`: Biba, Clark-Wilson
    - `机密性`: BLP、Chinese Wall
- 微服务架构的
    - 优点
        - `可以配合敏捷模型`
        - `技术选型灵活`
        - `设计上松耦合`
    - 缺点:
        1. `复杂性`：微服务架构涉及到分布式系统，需要处理分布式事务、服务发现、服务治理等复杂同题。
        2. `部署和测试`: 由于微服务的数量增加，部署和测试变得更加复杂。
        3. `运维成本`：微服务架构需要更多的运维工作，包括监控、日志收集、故障排查等。

- 分布式锁应具有的特性: ✨`性用重锁塞`

    - `高性能`的获取锁与释放锁
    - `高可用`的获取锁与释放锁
    - `可重入`特性
    - `锁失效`机制，防止死锁
    - `非阻塞`锁特性，即没有获取到锁将直接返回获取锁失败

- 云原生架构原则✨`自观人演服弹零信任`
    - `韧性`原则: 韧性代表了当软件所依赖的`软硬`件组件出现各种`异常`时，软件表现出来的`抵御`能力. 核心目标是提升软件的`平均无故障时间`。从架构设计上，韧性包括服务异步化能力、重试／限流／降级／熔断、主从模式、集群模式等。
    - `演进`原则: 技术和业务的演进速度非常快，很少有一开始就清晰定义了架构并在整个软件生命周期里面都适用，相反往往还需要对架构进行一定范围内的`重构`. 除了增量迭代、目标选取等因素外，还需要考虑组织(例如架构控制委员会)层面的架构治理和风险控制，特别是在业务高速迭代情况下的架构、业务、实现平衡关系。
    - `服务化`原则: 通过服务化架构把`不同生命周期`的模块分离出来，分别进行业务迭代，避免迭代频繁模块被慢速模块拖慢，从而加快整体的进度和稳定性。同时服务化架构以`面向接口编程`，服务内部的功能高度内聚，模块间通过公共功能模块的提取`增加软件的复用程度`。
    - `弹性`原则: 系统的部署规模可以随着业务量的变化而自动伸缩，无须根据事先的容量规划准备固定的硬件和软件资源。好的弹性能力不仅缩短了从采购到上线的时间，降低了企业的IT成本，更关键的是当业务规模面临海量突发性扩张的时候，不再因为平时软硬件资源储备不足而说不，保障了企业收益。
    - `自动化`原则: 大量自动化交付工具在CI/CD流水线中的实践，一方面标准化企业内部的软件交付过程，另一方面在标准化的基础上进行自动化，通过配置数据自描述和面向终态的交付过程，让自动化工具理解交付目标和环境差异，实现整个软件交付和运维的自动化。
    - `可观测`原则: 在云这样的分布式系统中，主动通过日志、链路跟踪和度量等手段，使得一次点击背后的多次服务调用的耗时、返回值和参数都清晰可见，甚至可以下钻到每次三方软件调用、SQL请求、节点拓扑、网络响应等
    - `零信任`原则: 默认情况下不应该信任网络内部和外部的任何人／设备／系统，需要基于认证和授权重构访问控制的信任基础. 零信任第一个核心问题就是身份(Identity),赋予不同的实体不同的身份，解决是谁在什么环境下访问某个具体的资源的问题。

- `建模`、`仿真`和基于数据融合的`数字线程`是数字挛生体的三项核心技术。

- 边缘计算的6种协同: ✨`服务业务需要智能应用数据资源`

    - `资源`协同：
        - 边缘节点提供计算、存储、网络、虚拟化等基础设施资源、具有本地资源调度管理能力，同时可与云端协同，
        - 接受并执行云端资源`调度`管理策略，包括边缘节点的设备管理、资源管理以及网络连接管理。
    - `数据`协同：
        - 云端提供海量数据的`存储、分析`与价值挖掘。边缘与云的数据协同，支持数据在边缘与云之间可控有序流动，形成完整的数据流转路径，高效低成本对数据进行生命周期管理与价值挖掘。
        - 边缘节点主要负责现场／终端数据的`采集`，按照规则或数据模型对数据进行初步处理与分析，并将处理结果以及相关数据上传给云端；
    - `智能`协同：
        - 云端开展AI的集中式模型`训练`，并将模型下发边缘节点。
        - 边缘节点按照AI模型`执行`推理，实现分布式智能；
    - `应用管理`协同：
        - 云端主要提供应用`开发、测试`环境，以及应用的生命周期管理能力。
        - 边缘节点提供应用`部署与运行`环境，并对本节点多个应用的生命周期进行管理调度；
    - `业务管理`协同：
        - 云端主要提供按照客户需求实现应用／数字挛生／网络等的业务`编排`能力。
        - 边缘节点提供模块化、微服务化的应用／数字孪生／网络等`应用`实例；
    - `服务`协同：
        - 云端主要提供SaaS服务在云端和边缘节点的服务`分布策略`，以及云端承担的SaaS服务能力。
        - 边缘节点按照云端策略实现部分`ECSaaS`服务，通过ECSaaS与云端Saas的协同实现面向客户的按需SaaS服务；

- CPS的实现包含: `单元级`, `系统级`, `SoS`
- CPS的技术体系可以分为四大核心技术要素，即一硬`(感知和自动控制)`、一软`(工业软件)`、一网`(工业网络)`、一平台`(工业云和智能服务平台)`

- 可靠性设计包含:
    - `容错`设计技术
    - `检错`技术
    - `降低复杂度`设计
    - `系统配置`技术

- 💛系统架构评估的方法通常可以分为3类：基于`()`或检查表的方式、基于`()`的方式和基于`()`的方式。

- 💛系统架构评估的质量属性(✨`性靠用安, 改变作功, 易(理解操作)测伸(伸缩)`):
    1. `性能`
    2. `可靠性`
        1. `容错性`
        2. `健壮性`
    3. `可用性`
    4. `安全性`(✨`整机不可控审`)
        1. `完整性`
        2. `机密性`
        3. `不可否认性`
        4. `可控性`
    5. `可修改性`(✨`展护移重`)
        1. `可拓展性`
        2. `可维护性`
        3. `可移植性`
        4. `重构`
    6. `可变性`
    7. `互操作性`
    8. `功能性`

- 事件系统(EDA)
    - 特点:
        - `异步`
        - `解耦`
    - 步骤: ✨`事件`和`事件总线`是两个构件, `发布事件`和`处理事件`是两个动作分别对应`定义事件注册处理器`和`定义事件处理器`
        - `定义事件`：定义事件的类型、属性和数据。事件可以是内部系统状态变化引起的，也可以是外部环境或其他系统引起的。
        - `定义事件总线`：定义事件总线的类型、协议和通信机制。事件总线可以是基于消息队列的、基于网络socket的、或者基于其他通信机制的。
        - `定义事件处理器`：定义事件处理器的类型、方法和逻辑。事件处理器可以是函数、方法、类或者其他可执行代码。
        - `注册处理器`：将事件处理器注册到事件总线上，使其可以接收到相应的事件。
        - `发布事件`：当事件发生时，将事件发布到事件总线上，使注册的事件处理器可以接收到事件。
        - `处理事件`：当事件处理器接收到事件后，执行相应的处理逻辑。

- 💛黑板

- ABSD方法有3个基础. ✨`功能, 质量和商业需求, 软件模板`
    - 第1个基础是`功能`的分解。
    - 第2个基础是通过选择体系结构风格来实现`质量`和`商业需求`。
    - 第3个基础是`软件模板`的使用，软件模板利用了一些软件系统的结构。
- ABSD在最顶层，系统被分解为若干`概念子系统`和一个或若干个`软件模板`。在第2层，概念子系统又被分解成`概念构件`和一个或若干个`附加软件模板`。
- ABSD模型把整个基于体系结构的软件过程划分为体系结构`需求`、`设计`、`文档化`、`复审`、`实现`和`演化`6个子过程. ✨在设计和实现中间加了`文档化`和`复审`, `实现`包含了开发, 测试, 维护, 最后增加了`演化`.
- 体系结构需求一般来自3个方面，分别是系统的`质量目标`、系统的`商业目标`和系统开发人员的`商业目标`。

- ✨redis在内存不足时的解决策略
    - 维度1: 区分有过期时间的key: `volatile`和无过期时间的key: `allkeys`
    - 维度2: 删除的策略
        - lru(Least Recently Used): 时间度量, 如果数据在`最近`一段时间内`没有`被访问，那么在将来也不太可能被访问。
        - lfu(Least Frequently Used): 频次度量, ：如果某个数据在最近一段`时间`内被访问`次数`很少，那么在将来也不太可能被频繁访问。
        - reandom: 随机删除
        - ttl(Time To Live): 删除过期时间最早的, 这个维度只有有过期时间的key有, 无过期时间的自然没有ttl. 所以组合起来共有2*4-1=7个组合

- 软件逆向工程的级别:✨`实结工龄`

    1. `实现`级：包括程序的抽象语法树、`符号`表、过程的设计表示。
    2. `结构`级：包括反映程序分量之间相互`依赖`关系的信息，例如调用图、结构图、程序和数据结构。
    3. `功能`级：包括反映程序段`功能`及程序段之间关系的信息，例如数据和控制流模型。
    4. `领域`级：包括反映程序分量或程序诸实体与应用`领域`概念之间对应关系的信息，例如E-R模型。

- 软件风险管理包括: `识别`, `预测`, `评估`, `控制`

- 构件组装方式:✨`顺层叠`

    1. `顺序`组装
    2. `层次`组装
    3. `叠加`组装

- 构件组装的三种不兼容问题(通过编写适配器解决)：✨方法名字参数都是`不兼容`, 子集是`不完备`

    1. 参数: `参数不兼容`。接口每一侧的操作有相同的名字，但参数类型或参数个数不相同。
    2. 操作:
        1. `操作不兼容`。提供接口和请求接口的操作名不同。
        2. `操作不完备`。一个构件的提供接口是另一个构件请求接口的一个子集，或者相反。

- 构件分类方法：
    1. `关键字`分类法: 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。
    2. `刻面`分类法: 利用Facet(刻面)描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。
    3. `超文本`方法: 基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。

- 💛软件测试基本流程

    1. `()`
    2. `()`
    3. `()`

- 静态白盒测试✨`()`

    - `()`法✨`()`
        - `()`: 程序员自己检查
        - `()`: 审查小组通过读程序和对照错误检查表进行检查
        - `()`: 审查小组需要准备有代表性的测试用例沿程序逻辑运行
    - `()`法✨`()`IDE的功能
        - `()`: 如函数调用关系图表, 模块控制流图表
        - `()`主要用于确定在源程序中是否有某类错误或“危险”结构

- 黑盒测试方法✨`等价类, 边界值, 错误, 因果图`

    - `等价类`划分(取一个值代表一类)
        - 有效等价类
        - 无效等价类
    - `边界值`分析
    - `错误`推测方法
    - `因果图`法
- 面向对象设计的原则(拓展)

    - `单一职责`原则：修改某个类的原因有且只有一个，让一个类只做一种责任。
    - `开放封闭`原则(open - close原则)：对扩展是开放的，对修改是封闭的。
    - `依赖倒置`原则：抽象不应该依赖于细节，细节应该依赖于抽象。即高层模块不应该依赖于底层模块，二者都应该依赖于抽象。

1. 模块结构设计院子
    1. `信息隐藏与抽象`: 信息隐藏原则要求采用封装技术，将程序模块的实现细节(过程或数据)隐藏起来
    2. `模块化`: 在描述一个模块时，必须按模块的外部特性与内部特性分别描述。
    3. `耦合`: ✨`直接数据标记控制通信的公共内容`
    4. `内聚`: ✨`能顺通过时既然`

- RUP的生命周期, 9个核心工作流:✨2~6是正常的, 7819`变更项目建模的环境`

    1. `业务建模`(Business Modeling)
    2. `需求`(Requirements)
    3. `分析与设计`(Analysis & Design)
    4. `实现`(Implementation)
    5. `测试`(Test)
    6. `部署`(Deployment)
    7. `配置与变更管理`(Configuration &  ChangeManagement)
    8. `项目管理`(Project Management)
    9. `环境`(Environment)

- 能力成熟度模型集成(CMMI)✨`初始缺乏管理项目的义务组织, 定量对度量, 优化对改进`.
    - `初始`级：过程不可预测且`缺乏`控制。
    - 已`管理`级：过程为`项目`服务。
    - 已`定义`级：过程为`组织`服务。
    - `定量`管理级：过程已`度量`和控制。
    - `优化`级：集中过程`改进`。

- 对等网络(peer-to-peer)中，每一个节点的地位都是对等的，既当服务器，同时也享有其他节点提供的服务，因此P2P网络的延迟与终端数量是`有关`的

## 考察问

- 💚开放系统互联安全体系的`五类安全服务`包括`()`、`()`、数据`()`性、数据`()`性和`()`性✨记`()`(鉴别身份)和`()`(授予权限), 剩下三个是整机不可控审的前`()`个

- 💛安全模型设计目的:✨BLP和Chinese Wall是`()`性, 其他是`()`性
    - `()`: BLP、Chinese Wall
    - `()`: Biba, Clark-Wilson

- 💚面向服务架构设计(Service Oriented Architecture, SOA)定义: 将应用`()`拆分成不同`()`, 通过这些服务之间定义良好的`()`联系起来。

- ❤️微服务架构的
    - 优点
        - `()`
        - `()`
        - `()`
    - 缺点:
        1. `()`：微服务架构涉及到分布式系统，需要处理分布式事务、服务发现、服务治理等复杂同题。
        2. `()`: 由于微服务的数量增加，部署和测试变得更加复杂。
        3. `()`：微服务架构需要更多的运维工作，包括监控、日志收集、故障排查等。

- 💚微服务架构图
    - 注册发现和配置管理：`()`
        - `()`
        - `()`
        - `()`
    - 远程调用：`()`
    - 链路监控：`()`
    - 服务保护：`()`
        - `()`
        - `()`
        - `()`
        - `()`, 使用`()`:
            - `()`
            - `()`
            - `()`
    - 统一网关路由：`()`
        - `()`, `()`, `()`
        - `()`

- 💚服务注册和发现的流程

    1. 服务提供者会在启动时`()`到`()`
    2. 服务消费者可以从`()`中`()`服务信息
    3. `()`，挑选一个实例
    4. `()`

    ✨服务提供者通过`()`机制向注册中心报告自己的`()`，当心跳异常时注册中心会将异常服务`()`，并`()`订阅了该服务的消费者

- 💚一致性问题解决方案:
    - `()`
    - `()`
    - `()`

- 💚两阶段提交协议

    - 第一阶段：`()`阶段协调者通知参与者`()`, 但`()`，参与者`()`后向协调者回应Yes(成功)或No(失败), 既`()`。

    - 第二阶段：`()`阶段协调者根据参与者的投票结果发起最终的`()`事务或`()`事务的指令。

    优缺点:

    - 优点：`()`一致性
    - 缺点：性能`()`, 灵活性`()`

- 💚事务补偿(TCC)

    1. Try: `()`并`()`好资源。
    2. Confirm: `()`预留的资源。
    3. Cancel: 如果任一执行出现问题则全部`()`并`()`资源。

    - 优点：性能`()`, 灵活性`()`
    - 缺点：`()`一致性, 要`()`

- 💚消息队列实现最终一致性

    1. 订单服务和库存服务完成`()`和`()`资源
    2. 订单服务在本地事务中完成
        1. `()`
        2. `()`
    3. 由`()`根据`()`的记录发送给MQ通知`()`执行减库存操作
    4. 库存服务在本地事务中完成
        1. `()`，
        2. 并且`()`（为避免重复执行消息，在执行减库存之前查询是否执行过此消息）
    5. 库存服务向MQ发送`()`
    6. 订单服务接收到完成库存减少的消息后`()`

    优缺点:
    - 优点：`()`，性能`()`。开发成本比TCC`()`。
    - 缺点：浪费`()`资源，另外对于高并发操作不是最佳方案。

- 💚幂等性: 是指对同一个`()`, 无论`()`多少次，其结果都`()`。实现方式有：

    - 在数据库表中加一个状态字段（未处理，已处理），数据操作时判断`()`时再处理。
    - 操作之前在业务方法进行判断如果执行过了就`()`执行。
    - 缓存所有请求和处理的结果，已经处理的请求则`()`结果。

- ❤️分布式锁应具有的特性: ✨`()`

    - `()`的获取锁与释放锁
    - `()`的获取锁与释放锁
    - `()`特性
    - `()`机制，防止死锁
    - `()`锁特性，即没有获取到锁将直接返回获取锁失败

- ❤️定义: ✨将云应用中的`()`业务代码部分进行最大化的剥离，从而让`()`(IaaS和PaaS)接管应用中原有的大量`()`业务特性(如弹性、韧性、安全、可观测性、灰度等).

- ❤️云原生架构原则✨`()`
    - `()`原则: 韧性代表了当软件所依赖的`()`件组件出现各种`()`时，软件表现出来的`()`能力. 核心目标是提升软件的`()`。从架构设计上，韧性包括服务异步化能力、重试／限流／降级／熔断、主从模式、集群模式等。
    - `()`原则: 技术和业务的演进速度非常快，很少有一开始就清晰定义了架构并在整个软件生命周期里面都适用，相反往往还需要对架构进行一定范围内的`()`. 除了增量迭代、目标选取等因素外，还需要考虑组织(例如架构控制委员会)层面的架构治理和风险控制，特别是在业务高速迭代情况下的架构、业务、实现平衡关系。
    - `()`原则: 通过服务化架构把`()`的模块分离出来，分别进行业务迭代，避免迭代频繁模块被慢速模块拖慢，从而加快整体的进度和稳定性。同时服务化架构以`()`，服务内部的功能高度内聚，模块间通过公共功能模块的提取`()`。
    - `()`原则: 系统的部署规模可以随着业务量的变化而自动伸缩，无须根据事先的容量规划准备固定的硬件和软件资源。好的弹性能力不仅缩短了从采购到上线的时间，降低了企业的IT成本，更关键的是当业务规模面临海量突发性扩张的时候，不再因为平时软硬件资源储备不足而说不，保障了企业收益。
    - `()`原则: 大量自动化交付工具在CI/CD流水线中的实践，一方面标准化企业内部的软件交付过程，另一方面在标准化的基础上进行自动化，通过配置数据自描述和面向终态的交付过程，让自动化工具理解交付目标和环境差异，实现整个软件交付和运维的自动化。
    - `()`原则: 在云这样的分布式系统中，主动通过日志、链路跟踪和度量等手段，使得一次点击背后的多次服务调用的耗时、返回值和参数都清晰可见，甚至可以下钻到每次三方软件调用、SQL请求、节点拓扑、网络响应等
    - `()`原则: 默认情况下不应该信任网络内部和外部的任何人／设备／系统，需要基于认证和授权重构访问控制的信任基础. 零信任第一个核心问题就是身份(Identity),赋予不同的实体不同的身份，解决是谁在什么环境下访问某个具体的资源的问题。

- 💚分层架构本身没有规定要分成多少层，大部分的应用会分成`()`层、`()`层、`()`层, `()`层。

- ❤️`()`、`()`和基于数据融合的`()`是数字挛生体的三项核心技术。
- 💚云边各有所长

    - 云计算擅长`()`性、`(非实/实)`时、`(长/短)`周期的`(大/小)`数据处理与分析，能够在长周期维护、业务决策支撑等领域发挥优势
    - 边缘计算更适用`()`性、`(非实/实)`时、`(长/短)`周期`(大/小)`数据的处理与分析，能更好地支撑本地业务的实时智能化决策与执行

- ❤️边缘计算的6种协同: ✨`()`

    - `()`协同：
        - 边缘节点提供计算、存储、网络、虚拟化等基础设施资源、具有本地资源调度管理能力，同时可与云端协同，
        - 接受并执行云端资源`()`管理策略，包括边缘节点的设备管理、资源管理以及网络连接管理。
    - `()`协同：
        - 云端提供海量数据的`()`与价值挖掘。边缘与云的数据协同，支持数据在边缘与云之间可控有序流动，形成完整的数据流转路径，高效低成本对数据进行生命周期管理与价值挖掘。
        - 边缘节点主要负责现场／终端数据的`()`，按照规则或数据模型对数据进行初步处理与分析，并将处理结果以及相关数据上传给云端；
    - `()`协同：
        - 云端开展AI的集中式模型`()`，并将模型下发边缘节点。
        - 边缘节点按照AI模型`()`推理，实现分布式智能；
    - `()`协同：
        - 云端主要提供应用`()`环境，以及应用的生命周期管理能力。
        - 边缘节点提供应用`()`环境，并对本节点多个应用的生命周期进行管理调度；
    - `()`协同：
        - 云端主要提供按照客户需求实现应用／数字挛生／网络等的业务`()`能力。
        - 边缘节点提供模块化、微服务化的应用／数字孪生／网络等`()`实例；
    - `()`协同：
        - 云端主要提供`()`服务在云端和边缘节点的服务分布策略，以及云端承担的SaaS服务能力。
        - 边缘节点按照云端策略实现部分`()`服务，通过ECSaaS与云端Saas的协同实现面向客户的按需SaaS服务；
- 💚企业信息系统的总体框架✨只记第一层和第三层
    - 战略管理: `()`系统
    - 战术管理: `()`系统和`()`系统
    - 运行管理: `()`
- 💛CPS的实现包含: `()`, `()`, `()`
- 💛CPS的技术体系可以分为四大核心技术要素，即一硬`()`、一软`()`、一网`()`、一平台`()`
- 💛可靠性设计包含:
    - `()`设计技术
    - `()`技术
    - `()`设计
    - `()`技术

- 💚情景生成: `()`, `()`, `()`

- 💚质量属性效用树:

    1. 树根: `()`
    2. 1级分支: `()`(性能, 可用性, 安全性, 可修改性)
    3. 2级分支: 质量属性的细分`()`
        1. 性能: 响应延迟, 吞吐量
        2. 可用性: 软硬件故障
        3. 安全性: 机密性, 完整性
        4. 可修改行: 新产品, 业务改变
    4. 3级分支: `()`
- 💚ATAM: ✨`()`
    1. 介绍: 业务
    2. 分析与测试: `()`
        1. `()`生成
        2. `()`生成
        3. 场景进行`()`
        4. 并分析`()`, `()`, `()`
    3. 报告
- 💚架构定义一个`()`和一组`()`。
    - 词汇表中包含一些`()`和`()`类型，
    - 约束指出系统是如何将这些构件和连接件`()`起来的。
- 💛系统架构评估的方法通常可以分为3类：基于`()`或检查表的方式、基于`()`的方式和基于`()`的方式。

- 💛系统架构评估的质量属性(✨`()`):
    1. `()`
    2. `()`
        1. `()`
        2. `()`
    3. `()`
    4. `()`
        1. `()`
        2. `()`
        3. `()`
        4. `()`
    5. `()`
        1. `()`
        2. `()`
        3. `()`
        4. `()`
    6. `()`
    7. `()`
    8. `()`
- 💚DSSA的基本活动:✨实现包含了`()`
    1. 领域`()`: 获得`()`
    2. 领域`()`: 获得DSSA
    3. 领域`()`
- 💚DSSA的参与人员: 领域`()`, 领域`()`人员, 领域`()`人员, 领域`()`人员
- 💛事件系统(EDA)
    - 特点:
        - `()`
        - `()`
    - 步骤: ✨`()`
        - `()`：定义事件的类型、属性和数据。事件可以是内部系统状态变化引起的，也可以是外部环境或其他系统引起的。
        - `()`：定义事件总线的类型、协议和通信机制。事件总线可以是基于消息队列的、基于网络socket的、或者基于其他通信机制的。
        - `()`：将事件处理器注册到事件总线上，使其可以接收到相应的事件。
        - `()`：当事件发生时，将事件发布到事件总线上，使注册的事件处理器可以接收到事件。
        - `()`：定义事件处理器的类型、方法和逻辑。事件处理器可以是函数、方法、类或者其他可执行代码。
        - `()`：当事件处理器接收到事件后，执行相应的处理逻辑。
- 💚仓库
    - 构件:
        - 中央数据库的作用: `()`
        - 独立构件的作用: `()`
    - 连接件: 仓库与独立构件之间的交互
- 💛黑板
- 💚ABSD由架构驱动，即由构成架构的`()`、`()`和`()`需求的组合驱动架构设计。✨`()`
- ❤️ABSD方法有3个基础. ✨`()`
    - 第1个基础是`()`的分解。
    - 第2个基础是通过选择体系结构风格来实现`()`和`()`。
    - 第3个基础是`()`的使用，软件模板利用了一些软件系统的结构。
- ❤️ABSD在最顶层，系统被分解为若干`()`和一个或若干个`()`。在第2层，概念子系统又被分解成`()`和一个或若干个`()`。
- 💚软件架构的4+1视图: ✨`()`, `()`
- ❤️ABSD模型把整个基于体系结构的软件过程划分为体系结构`()`、`()`、`()`、`()`、`()`和`()`6个子过程. ✨在设计和实现中间加了`()`和`()`, `()`包含了开发, 测试, 维护, 最后增加了`()`.
- ❤️体系结构需求一般来自3个方面，分别是系统的`()`、系统的`()`和系统开发人员的`()`。

- 💛redis在内存不足时的解决策略✨`7`(两个维度组合)+`1`(默认不删)

    - 维度1: 区分有过期时间的key: `()`和无过期时间的key: `()`
    - 维度2: 删除的策略
        - `()`: 时间度量, 如果数据在最近一段时间内没有被访问，那么在将来也不太可能被访问。
        - `()`: 频次度量, 如果某个数据在最近一段时间内被访问次数很少，那么在将来也不太可能被频繁访问。
        - `()`: 随机删除
        - `()`: 删除过期时间最早的, 这个维度只有有过期时间的key有, 无过期时间的自然没有ttl. 所以组合起来共有2*4-1=7个组合

- 💚购物车

    以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素，如下图所示。

    涉及的命令如下：✨每个用户一个购物车, 既一个HASH的Key

    - 添加商品：`()`
    - 添加数量：`()`
    - 商品总数：`()`
    - 删除商品：`()`
    - 获取购物车所有商品：`()`

- 💚共同关注

    Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。

    key可以是用户id，value 则是已关注的公众号的 id。

    1. 设置用户的关注公众号

        - uid:1 用户关注公众号 id 为 5、6、7、8、9: `()`
        - uid:2 用户关注公众号 id 为 7、8、9、10、11: `()`

    2. 获取uid:1和uid:2的共同关注 `()`

    3. 给 uid:2 推荐 uid:1 关注的公众号：`()`

    4. 验证某个公众号是否同时被 uid:1 或 uid:2 关注：`()`

- 💚抽奖活动

    存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。

    1. key 为抽奖活动名，value 为员工名称，把所有员工名称放入抽奖箱：`SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark`
    2. 允许重复抽奖
        1. 抽取1个一等奖：`SRANDMEMBER lucky 1`
        2. 抽取2个二等奖: `SRANDMEMBER lucky 2`
        3. 抽取3个三等奖: `SRANDMEMBER lucky 3`
    3. 不允许重复抽奖

        1. 抽取1个一等奖：`SPOP lucky 1`
        2. 抽取2个二等奖: `SPOP lucky 2`
        3. 抽取3个三等奖: `SPOP lucky 3`

- 💚连续签到用户总数: 🌰假设要统计3天连续打卡的用户数，则是将三个Bitmap进行AND操作，并将结果保存到destmap中，接着对destmap执行BITCOUNT统计，如下命令：✨首先实现判断用户是否登录过: key是`()`, offset是`()`, value是`()`. 再将3个bitmap进行与运算

    1. 与操作. `()`
    2. 统计bit位 = 1的个数. `()`

  💚在redis.conf中的save字段配置RDB策略

    - save 60 1000的含义, `()`

- 💚哨兵的作用如下：

    - `()`：Sentinel 会不断检查您的master和slave是否按预期工作
    - `()`：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端
    - `()`：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主

- 💚`()`是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。Spring也在使用。

- 💚并发控制, 隔离性破坏
    - `()`: T_1和T_2分别读相同变量, T_2的写覆盖了T_1的写. T_2本应该在T_1修改后, 再读再写.
    - `()`: T_1前后两次读之间, T_2修改了数据
    - `()`: T_2读了T_1回滚前的数据.
    - `()`: T_1回滚覆盖了T_2修改的数据

- 💚不要求全部都记, 题型考察从算式推名称. 传递律和伪传递律好记, 然后记`自增分合`

- 💚范式分类
    - 1NF: `()`
    - 2NF: 无`()`
    - 3NF: 无`()`属性`()`
    - 4NF: 无`()`依赖

- 💚模式分解使用`()`和`()`来衡量模式分解后是否导致原有模式中部分信息丢失。
    - `()`: 将拆解的表还原
    - `()`: 分解后的小表, 默认是后面的列依赖前面的列

1. 💚关系(表)运算符:
    1. `()`
    2. `()`
    3. `()`
        1. 笛卡尔
        2. 自然(`相同的`列相等)

- 💛软件逆向工程的级别:✨`()`

    1. `()`级：包括程序的抽象语法树、符号表、过程的设计表示。
    2. `()`级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构。
    3. `()`级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型。
    4. `()`级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如E-R模型。

- 💚软件质量的因素划分为3组: 产品`()`, 产品`()`, 产品`()`
- 💛软件风险管理包括: `()`, `()`, `()`, `()`

- 💚项目活动图(PERT)

    - 顶点表示`()`，边表示`()`，边上的数字表示完成该活动所需要的`()`。
    - 关键路径：
        - 关键路径: 从开始里程碑到结束里程碑之间`()`的一条路径。遍历所有路径, 获取.
        - `()`: 关键路径上的时间长度
    - 松弛时间: 可以延误多久而不影响总工期. 计算公式为: 松弛时间 = 最迟开始时间-最早开始时间.
        - 关键路径上的活动的松弛时间均为0
        - 其他路径:
            - 最迟开始时间 = 关键路径时间 - 该`()`到项目活动图的`()`的`()`长度
            - 最早开始时间 = 项目活动图的`()`到`()`的`()`长度.

- 💚单代号网络图(PDM)

    - `()`表示`()`, `()`表示任务的`()`
    - 计算步骤
        1. `()`, 计算每个活动的最早开始时间和最早结束时间(活动的最`()`面一行)
            1. 最早开始时间
                1. 开始的活动为`()`
                2. 中间的活动为前一个活动的`()`时间. 如果依赖多个活动, 则取`()`的最早结束时间.
            2. 最早结束时间 = 最早开始时间 + 活动的持续时间
        2. `()`, 计算每个活动的最晚开始时间和最晚结束时间(活动的最`()`面一行)
            1. 最晚结束时间
                1. 最后一个活动的最晚结束时间 = 最`()`结束时间
                2. 中间的活动为后一个活动的`()`时间. 如果依赖多个活动, 则取最`()`的最晚开始时间.
            2. 最晚开始时间 = 最晚结束时间 - 活动的持续时间
            3. 松弛时间 = 最迟开始-最早开始或最迟完成和最早完成(竖向计算). 松弛时间为0的, 标记为关键路径.

1. 💛构件组装方式:✨`()`

    1. `()`组装
    2. `()`组装
    3. `()`组装

2. 💛构件组装的三种不兼容问题(通过编写适配器解决)：✨方法名字参数都是`()`, 子集是`()`

    1. 参数: `()`。接口每一侧的操作有相同的名字，但参数类型或参数个数不相同。
    2. 操作:
        1. `()`。提供接口和请求接口的操作名不同。
        2. `()`。一个构件的提供接口是另一个构件请求接口的一个子集，或者相反。

3. 💛构件分类方法：
    1. `()`分类法: 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。
    2. `()`分类法: 利用Facet(刻面)描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。
    3. `()`方法: 基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。

- 💛软件测试基本流程

    1. `()`
    2. `()`
    3. `()`

- 静态白盒测试✨`()`

    - `()`法✨`()`
        - `()`: 程序员自己检查
        - `()`: 审查小组通过读程序和对照错误检查表进行检查
        - `()`: 审查小组需要准备有代表性的测试用例沿程序逻辑运行
    - `()`法✨`()`IDE的功能
        - `()`: 如函数调用关系图表, 模块控制流图表
        - `()`主要用于确定在源程序中是否有某类错误或“危险”结构

- ❤️动态白盒测试✨`()`

    - ❤️`()`法: ✨`()`
        - `()`覆盖（Statement Coverage）: 每行代码都被执行
        - `()`覆盖（Decision Coverage）: 每个判定都被执行, 不考虑前后两个判定的组合
        - `()`覆盖（Condition Coverage）: 每个判定条件真假都被执行
        - `()`覆盖（Condition Decision Coverage）: 综合判定和条件,
        - `()`覆盖（Multiple Condition Coverage）:考虑前后所有判定条件的组合
        - `()`覆盖(Road Coverage): 每一条可能得路径都被执行

    - ❤️`()`测试法✨`()`

        如果某一程序的每一个独立路径都被执行到，那么就可以认为程序中的每个语句都已经检验过了，即达到了语句覆盖。这种测试方法就是通常所说的基路径测试法。

        基本路径测试法的4个步骤:
        1. 以详细设计或源代码作为基础，绘制程序的`()`图。
        2. 计算得到的控制流图`()`复杂性V（G）。
        3. 确定独立路径的集合。通过程序控制流图导出基本路径集，列出程序的独立路径。所谓`()`，是指`()`，也就是包含一些前面的路径未包含的语句，当所有的语句都包含了，基路径集就够了。（线性无关路径）
        4. 设计测试用例，确保基本路径集中每条路径的执行。

- ❤️黑盒测试方法✨`()`

    - `()`划分(取一个值代表一类)
        - 有效等价类
        - 无效等价类
    - `()`分析
    - `()`推测方法
    - `()`法

- 💛面向对象设计的原则(拓展)

    - `()`原则：修改某个类的原因有且只有一个，让一个类只做一种责任。
    - `()`原则(open - close原则)：对扩展是开放的，对修改是封闭的。
    - `()`原则：抽象不应该依赖于细节，细节应该依赖于抽象。即高层模块不应该依赖于底层模块，二者都应该依赖于抽象。

- 💛模块结构✨`()`
    1. `()`: 信息隐藏原则要求采用封装技术，将程序模块的实现细节(过程或数据)隐藏起来
    2. `()`: 在描述一个模块时，必须按模块的外部特性与内部特性分别描述。
    3. `()`: ✨`()`
    4. `()`: ✨`()`

- 💚敏捷开发的4种方法:
    - `()`
    - `()`
    - `()`
    - `()`

- ❤️RUP的生命周期, 9个核心工作流:✨2~6是正常的, 7819`()`

    1. `()`(Business Modeling)
    2. `()`(Requirements)
    3. `()`(Analysis & Design)
    4. `()`(Implementation)
    5. `()`(Test)
    6. `()`(Deployment)
    7. `()`(Configuration & Change Management)
    8. `()`(Project Management)
    9. `()`(Environment)

- 💚能力成熟度模型集成(CMMI)✨`()`.
    - `()`级：过程不可预测且缺乏控制。
    - 已`()`级：过程为项目服务。
    - 已`()`级：过程为组织服务。
    - `()`管理级：过程已`()`和控制。
    - `()`级：集中过程`()`。

- 💛UML的图包括:
    1. `()`图: ✨`()`(`()`图, `()`图, `()`图, `()`图, `()`图, `()`图)
    2. `()`图: ✨`()`(`()`图, `()`图, `()`图, `()`图, `()`图, `()`图, `()`图)

- 💚TCP和UDP区别, 从()和()两方面对比
- 💚Internet网络核心采取的交换方式为`()`交换
- 💚如果不考虑网络环境，服务器的延迟的主要因素是`()`延迟和`()`延迟。
- ❤️对等网络(peer-to-peer)中，每一个节点的地位都是对等的，既当服务器，同时也享有其他节点提供的服务，因此P2P网络的延迟与终端数量是`()`的

- 💚信道的最大数据传输速率 = `()` * $log_2{`()`}$

- 💚循环冗余校验原理
    1. 循环冗余校验步骤
        1. 被除数: `()`+`()`个`0`(从`()`次项开始计算, 不包含常数项)
        2. 除数: 多项式每项是否存在(从`()`次项)
        3. 模2除法: 相同为`()`, 不同为`()`, 不进位, 不退位, 余数既为校验码
    2. `()`检错, `()`纠错
- 💚海明码长度计算公式
    1. 计算步骤:
        1. $k$是原数据的`()`
        2. 枚举$r$, 找到满足$2^{r}\geq k + r + 1$的`()`的$r$
        3. 海明码长度为$`()`$
    2. `()`检错, `()`纠错

- 💚运算器和控制器的组件
    - CPU的两个组成部分是`()`和`()`
    - 运算器的组件包含哪些
        - 算术逻辑单元(Arithmetic Logic Unit, ALU)的作用: `()`
        - 累加寄存器(Accumulator Register，AR)的作用: `()`
        - 数据缓冲寄存器(Data Register, DR)的作用: `()`
        - 状态条件寄存器(Program Status Word，PSW)的作用: `()`

        ✨`()`计算, `()`数据; CPU到内存是`()`.

    - 控制器的组件包含哪些
        - 指令寄存器(Instruction Register，IR)的作用: `()`指令
        - 程序计数器(Program Counter，PC)的作用: `()`指令
        - 地址寄存器(Address Register，AR)的作用: `()`地址
        - 指令译码器(Instruction Decoder，ID)的作用: `()`

        ✨当前指令`()`, 下一条指令`()`, 要操作的数据`()`

- 💚专用目的处理器芯片

    - 数字信号处理器(Digital Signal Processor, DSP)处理`()`
    - 微处理器(Microprocessor Unit, MPU)类似`()`
    - 片上系统(System on Chip, SOC)是`()`
    - 微控制单元, 单片机(Microcontroller Unit，MCU)是`()`
