# 死锁

## 最佳实践

### 考试总结

3. (✨2025上)操作系统中有5个进程，若每个进程最多可同时访问2个资源，为了不发生死锁，至少需要提供( )个资源。

    - A.6
    - B.5
    - C.8
    - D.10

    答案: A

1. 🟨假设系统中有三类互斥资源R₁、R₂、R₃，可用资源数分别为8、7和4。在T₀时刻系统中有P₁、P₂、P₃、P₄、P₅这5个进程，这些进程对资源的最大需求量和已分配资源数如下表所示。

    |进程|最大需求量(R₁ R₂ R₃)|已分配资源数(R₁ R₂ R₃)|
    | ---- | ---- | ---- |
    |P₁|6 4 2|1 1 1|
    |P₂|2 2 2|2 1 1|
    |P₃|8 1 1|2 1 0|
    |P₄|2 2 1|1 2 1|
    |P₅|3 4 2|1 1 1|

    若有如下4个执行序列，那么进程按_____序列执行，系统状态是安全的。

    - A. P₁ → P₂ → P₄→ P₅→ P₃
    - B. P₂ → P₁ → P₄→ P₅→ P₃
    - C. P₄ → P₂ → P₁→ P₅→ P₃
    - D. P₄ → P₂ → P₅→ P₁→ P₃

    答案: D

    |进程/资源|最大需求量(R₁ R₂ R₃)|已分配资源数(R₁ R₂ R₃)|还需要资源数(R₁ R₂ R₃)|
    | ---- | ---- | ---- | ---- |
    |P₁| 6 4 2|1 1 1|5 3 1|
    |P₂| 2 2 2|2 1 1|0 1 1|
    |P₃| 8 1 1|2 1 0|6 0 1|
    |P₄| 2 2 1|1 2 1|1 0 0|
    |P₅| 3 4 2|1 1 1|2 3 1|
    |已分配总数||7 6 4|
    |剩余资源数||1 1 0|

2. 🟨假设系统中互斥资源R的可用数为25。T0时刻进程P1、P2、P3、P4对资源R的最大需求数、已分配资源数和尚需资源数的情况如表1所示，若P1和P3分别申请资源R数为1和2，则系统(  )。表1 T0时刻进程对资源的需求情况

    |进程|最大需求数|已分配资源数|尚需资源数|
    | ---- | ---- | ---- | ---- |
    |P1|10|6|4|
    |P2|11|4|7|
    |P3|9|7|2|
    |P4|12|6|6|

    - A. 只能先给P1进行分配，因为分配后系统状态是安全的
    - B. 只能先给P3进行分配，因为分配后系统状态是安全的
    - C. 可以同时给P1、P3进行分配，因为分配后系统状态是安全的
    - D. 不能给P3进行分配，因为分配后系统状态是不安全的

    答案: B

### 考察问

- 死锁的概念: 进程因`()`而陷入`()`等待的现象
- 发生死锁资源个数的计算

    n个进程, 每个进程需R个资源, 则死锁的可能发生资源范围`()`

    1. 必然发生死锁的资源数为`()`
    2. 可能发生死锁的资源数为`()`
    3. 不可能发生死锁的资源数为`()`

    ✨只需记住可能发生死锁的资源闭区间个数即可.

    ✨想象一个表格, 有n行R列

    - 第1行的进程填满R个资源, 才能运行, 所以可能发生死锁的最小资源数是R
    - 所有行, 都填满R-1个资源, 都不能运行, 所以可能发生死锁的最大资源个数是n*(R-1)

- 不发生死锁的最佳执行路径
    1. 先计算每个`()`还需要的资源数
    2. 再计算目前每个`()`剩余的个数
    3. 填补`()`需要资源数的进程


### 考察点

- 死锁的概念: 进程因`争夺对方占用的资源`而陷入`无限`等待的现象
- 发生死锁资源个数的计算

    n个进程, 每个进程需R个资源, 则死锁的可能发生资源范围`[R, n * (R – 1)]`

    1. 必然发生死锁的资源数为`<R`
    2. 可能发生死锁的资源数为`[R, n * (R – 1)]`
    3. 不可能发生死锁的资源数为`> n * (R – 1)`

    ✨只需记住可能发生死锁的资源闭区间个数即可.

    ✨想象一个表格, 有n行R列

    - 第1行的进程填满R个资源, 才能运行, 所以可能发生死锁的最小资源数是R
    - 所有行, 都填满R-1个资源, 都不能运行, 所以可能发生死锁的最大资源个数是n*(R-1)

- 不发生死锁的最佳执行路径
    1. 先计算每个`进程`还需要的资源数
    2. 再计算目前每个`资源`剩余的个数
    3. 填补`最小`需要资源数的进程

## 死锁概念

死锁，是指两个以上的进程因`争夺对方占用的资源`而陷入`无限等待`的现象

## 死锁的四大条件

1. 互斥(资源互斥)
2. 保持和等待(进程占有资源并等待其他资源)
3. 不可剥夺(系统不可剥夺进程资源)
4. 环路(进程资源是一个环路)

![alt text](./3计算机软件概述/死锁.png)

## 死锁的处理策略

1. 死锁预防：采用某种策略限制并发进程对资源的请求，破坏死锁产生的4个必要条件，使系统在任何时刻都不满足产生死锁的必要条件。
2. 死锁避免：提前计算出一条不会产生死锁的资源分配方法。著名的死锁避免算法有银行家算法。
3. 死锁检测：允许死锁产生，但系统定时运行一个死锁检测程序，判断系统是否发生死锁，若检测到有死锁，则设法加以解除。
4. 死锁解除：即死锁发生后的解除方法，如资源剥夺法、撤销进程法等。

## 死锁资源计算

系统内有n个进程，每个进程都需要R个资源，那么

1. 必然发生死锁的资源数为`<R`
2. 可能发生死锁的资源数为`[R, n * (R – 1)]`
3. 不可能发生死锁的资源数为`> n * (R – 1)`

🔒系统有 3 个进程：A、B、C。这 3 个进程都需要 5 个系统资源。如果系统至少有多少个资源，则不可能发生死锁。

![alt text](./3计算机软件概述/死锁资源的计算.png)

1. 当`R<=4`个资源时, 一定会发生死锁, 既资源全给一个进程也不满足
2. 当`R = [5, 12]`个资源时, 可能会发生死锁(5是一个进程需要的最少资源, 12是进程数 x 每个进程需要的资源-1), 只要资源先给一个资源, 就不会发生死锁; 如果均分则发生死锁
3. 当`R >= 13`个资源时, 一定不会发生死锁. 资源全给一个进程, 或者均分都不会发生死锁

## 乐观锁和悲观锁

- 悲观锁（Pessimistic Lock）: 保证不出问题
- 乐观锁（Optimistic Lock）: 出了问题再处理

### 悲观锁

悲观锁认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。共享资源每次只给一个线程使用，其它线程阻塞. Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

高并发的场景下，激烈的锁竞争会造成线程阻塞，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。

### 乐观锁

乐观锁认为共享资源每次被访问的时候很少会出现问题(比如共享数据被修改), 所以只在提交修改的时候去验证对应的资源是否被其它线程修改了

高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，这样同样会非常影响性能，导致 CPU 飙升。

乐观锁一般会使用版本号机制或 CAS 算法实现.

#### 版本号机制

给资源加一个版本号`version`字段，表示数据被修改的次数。当数据被修改时, version值会加1。当线程A要更新数据值时:

1. 在`读取`数据时, 读取当前的version值, 保存.
2. 在`更新`数据时，再读取当前的version值, 保存.
    - 如果两个version值`相等`, 才更新，
    - 如果两个version值`不相等`, 则不能更新, 需要重试更新操作，直到更新成功。

🌰举例：假设帐户信息表中有一条记录: 帐户余额字段(balance)为100,  version字段当前值为1.

1. 程序员A此时将其读出（ version=1 ），并从其帐户余额中扣除 50（ 100-$50 ）。
2. 同时在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
3. 操作员 A 完成了修改工作, 且B尚未完成修改工作未提交. A再次读取版本号,  version仍然为1, 前后version一致, 期间既没有其他人提交, 所以A将余额50, 提交, 数据库自动将version改为2。
4. 操作员 B 完成了操作，但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不一致, 说明此期间已经有人将该数据做了修改，因此，操作员 B 的提交被驳回。这样就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。

#### CAS算法

CAS 的全称是 Compare And Swap（比较与交换）, CAS 涉及到三个操作数：

- V(Var)：要更新的变量值
- E(Expected)：预期值
- N(New)：拟写入的新值

当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。

🌰举例：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。

- i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。
- i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。 需要重试更新操作，直到更新成功。

✨版本机制和CAS区别, 前者增加额外的字段比较是否相等, CAS没有增加字段, 直接比较本身.

### 乐观锁和悲观锁的选择

理论上来说：

- 悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。
- 乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）。

### 参考

- <https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html>
