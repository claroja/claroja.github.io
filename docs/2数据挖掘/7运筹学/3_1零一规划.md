# 零一规划

## 问题
### 互斥的决策问题

互斥的决策问题，是指决策方案、计划互斥，如决定投资项目、确定投资场所、选择投产产品等。

例如，双十一的促销活动，淘宝、京东、拼多多要求店铺二选一，最多只能选择参加一家平台，否则可能会被封杀，这是典型的互斥决策问题。

背包问题就是经典的互斥决策问题。给定一组n个物品，每种物品i的价值为$v_i$、重量/体积为$w_i$，背包所能容纳的总重量/总容量为（B），如何选择其中若干种物品（每种物品选 0 个或 1 个），使得物品的总价值最高？

背包问题的建模方法如下：

定义决策变量为：
$$
x_i = \\
\begin{cases}
    0, 不选择第i个物品 \\
    1, 选择第i个物品
\end{cases}
$$

定义目标函数为:
$$
max f(x) = \sum_{i=1}^n v_i x_i \\
s.t. : \\
\begin{cases}
    \sum_{i=1}^n w_i x_i \leq B, \\
    x_i = 0, 1
\end{cases}
$$

很多应用问题都可以用上述的背包问题数学模型来表达，例如：

有 n个项目，每个项目所需投资额为 w_i，投产后的利润为 v_i，投资总限额为 B，求利润最大的投资方案；
处理器能力有限，任务很多，如何选择使处理器的效用最大；


### 互斥的约束问题
互斥的约束问题，是指具有多个互斥的约束条件，这些约束条件只有一个起作用。

例如，货物运输有车运或者船运两种运输方式可供选择，已知采用车运的约束条件和船运的约束条件，必须且只能选择其中一种运输方式。这两个约束条件互斥，有且只有一个起作用，这是可以引入一个 0-1变量来处理。
一般地，设有 m 个互斥的约束条件：
$$
a_{i1}x_1 + ... + a{in}x_n \leq b_i, i=1,...,m
$$
该类问题的建模方法，为了保证只有一个约束条件起作用，可以引入一个充分大的常数 M 和 m 个 0-1 变量表示约束是否起作用：
$$
y_i =
\begin{cases}
    0, 第i个约束不起作用 \\
    1, 第i个约束起作用
\end{cases}
$$
于是可以构造$m+1$个约束条件:
$$
s.t. : 
\begin{cases}
    a_{i1}+ ... + a_{in}x_n \leq b_i + (1-y_i)M, i=1,...,m \\
    y_i + ... + y_m = 1 \\
    y_i = 0, 1
\end{cases}
$$
由于 M 足够大，新的约束条件就能保证只有 y_i=1 的约束条件起作用，而其它约束条件都不起作用。



### 固定费用问题（Fixed cost problem）
固定费用问题，是指求解生产成本最小问题时，总成本包括固定成本和变动成本，而选择不同生产方式会有不同的固定成本，因此总成本与选择的生产方式有关。

固定费用问题，实际上是互斥的目标函数问题，对于不同的生产方式具有多个互斥的目标函数，但只有一个起作用。固定费用问题不能用一般的线性规划模型求解。

一般地，设有 m 种生产方式可供选择，采用第 j 种方式时的固定成本为$k_j$, 变动成本为$c_j$, 产量为$x_j$, 则采用各种生产方式的总成本分别为:

$$
min P_j = \\
\begin{cases}
    k_j + c_jx_j, x_j \geq 0 \\
    0, x_j=0, j=1,...,m
\end{cases}
$$

该问题的建模方法, 为了构造同一的目标函数, 可以引入m个0-1变量$y_j$表示是否采用第$j$种生产方式:
$$
y_j = \\
\begin{cases}
    0, 不采用第j种生产方式 \\
    1, 采用第j种生产方式
\end{cases}
$$
于是可以构造新的目标函数和约束条件:
$$
min f(x) = \sum_{j=1}^m(k_jy_j + c_jx_j) \\
s.t.: x_j \leq y_jM, j = 1,...,m
$$
$M$是一个充分大的常数.



### 指派问题
分配 n 个人去做 n 件工作，每人只做一件工作，每件工作只有一个人做，已知每个人做每件事的用时为$c_{ij}$，如何安排才能使花费的总时间最少。
引入0-1变量$x_{ij}$:
$$
x_{i,j} = \\
\begin{cases}
    0, 第i个人不做第j件工作  \\
    1, 第i个人做第j件工作, i,j=1,...,n
\end{cases}
$$
指派问题的数学模型可以描述为:
$$
min f(x) = \sum_{i=1}^n\sum_{j=1}^n(c_{ij}x_{ij})  \\
s.t.:
\begin{cases}
    \sum_{j=1}^n x_{ij} = 1, i=1,...,n \\
    \sum_{i=1}^n x_{ij} = 1, j=1,...,n \\
    x_{ij} = 0,1, i,j = 1,...,n
\end{cases}

$$

## 解决方法
目前 0-1 规划问题并没有通用、高效、精确的求解方法



### 隐枚举法（Implicit enumeration）
求解 0-1 规划问题的思路，首先是穷举法，遍历决策变量的所有的组合，求出目标函数的最优值。随着问题规模的增大，变量的组合成指数增长，穷举法就不可能实现了。

隐枚举法是通过反复构造过滤条件，不断删除比当前解差的解集，并把优于当前最优解的结果作为新的最优解，再以新的最优解构造新的过滤条件，如此反复直到求出最优解。


### 蒙特卡洛法（Monte Carlo）
蒙特卡洛法是一类随机方法的统称，也称随机取样法。顾名思义，蒙特卡洛法就是大量地对决策变量随机取值——如果能在满足约束条件的前提下随机取值就更好了，通过比较其目标函数值来不断获得更好的解，最后就能得到近似的最优解。

蒙特卡洛法的特点是，可以在随机采样上计算得到近似结果，采样越多，越近似最优解 ，但无法保证得到的结果是不是全局最优解。可以证明，在一定的计算量的情况下，蒙特卡洛法可以获得较好的满意解。

### 启发式算法（Heuristic algorithms）
启发式算法通常是以问题为导向的，没有一个通用的框架，根据具体问题的特殊结构来识别启发性信息，构造启发式优化过程来高效地寻找近似最优解。

启发式算法获得的近似最优解，通常是局部最优解。而且，启发式算法的解需要借助其他方法来评估其质量，并且在实际应用中不能保证为各种算例稳定地生成接近全局最优的可行解。

## python
公司有 5 个项目被列入投资计划，各项目的投资额和预期投资收益如下表所示（万元）：

项目|A|B|C|D|E
--|--|--|--|--|--
投资额|210|300|100|130|260
投资收益|150|210|60|80|180
公司只有 600万元资金可用于投资，综合考虑各方面因素，需要保证：
（1）项目 A、B、C 中必须且只能有一项被选中；
（2）项目 C、D 中最多只能选中一项；
（3）选择项目 E 的前提是项目 A被选中。
如何在上述条件下，进行投资决策，使收益最大。


### 建模分析
定义决策变量:
$$
x_i = 
\begin{cases}
    0, 不选择第i个项目 \\
    1, 选择第i个项目
\end{cases}
$$
定义目标函数为:
$$
\begin{cases}
    max f(x) = 150x_1 + 210x_2 + 60x_3 + 80x_4 + 180x_5 \\
    x_1 + x_2 + x_3 = 1 \\
    x_3 + x_4 \leq 1 \\
    x_5 \leq x_1 \\
    x_i = 0,1, i = 1,...,5 \\
\end{cases}
$$

```python
import pulp      # 导入 pulp 库

## 主程序
def main():
    # 投资决策问题：
    # 公司现有 5个拟投资项目，根据投资额、投资收益和限制条件，问如何决策使收益最大。
    """
    问题建模：
        决策变量：
            x1～x5：0/1 变量，1 表示选择第 i 个项目， 0 表示不选择第 i 个项目
        目标函数：
            max fx = 150*x1 + 210*x2 + 60*x3 + 80*x4 + 180*x5
        约束条件：
            210*x1 + 300*x2 + 100*x3 + 130*x4 + 260*x5 <= 600
            x1 + x2 + x3 = 1
            x3 + x4 <= 1
            x5 <= x1
            x1,...,x5 = 0, 1
    """
    InvestLP = pulp.LpProblem("Invest decision problem", sense=pulp.LpMaximize)  # 定义问题，求最大值
    x1 = pulp.LpVariable('A', cat='Binary')  # 定义 x1，A 项目
    x2 = pulp.LpVariable('B', cat='Binary')  # 定义 x2，B 项目
    x3 = pulp.LpVariable('C', cat='Binary')  # 定义 x3，C 项目
    x4 = pulp.LpVariable('D', cat='Binary')  # 定义 x4，D 项目
    x5 = pulp.LpVariable('E', cat='Binary')  # 定义 x5，E 项目
    InvestLP += (150*x1 + 210*x2 + 60*x3 + 80*x4 + 180*x5)  # 设置目标函数 f(x)
    InvestLP += (210*x1 + 300*x2 + 100*x3 + 130*x4 + 260*x5 <= 600)  # 不等式约束
    InvestLP += (x1 + x2 + x3 == 1)  # 等式约束
    InvestLP += (x3 + x4 <= 1)  # 不等式约束
    InvestLP += (x5 - x1 <= 0)  # 不等式约束
    InvestLP.solve()  # youcans
    print(InvestLP.name)  # 输出求解状态
    print("Status youcans:", pulp.LpStatus[InvestLP.status])  # 输出求解状态
    for v in InvestLP.variables():
        print(v.name, "=", v.varValue)  # 输出每个变量的最优值
    print("Max f(x) =", pulp.value(InvestLP.objective))  # 输出最优解的目标函数值

    return

if __name__ == '__main__':  # Copyright 2021 YouCans, XUPT
    main()  # Python小白的数学建模课 @ Youcans


"""
Welcome to the CBC MILP Solver 
Version: 2.9.0 
Build Date: Feb 12 2015 

Result - Optimal solution found

Invest_decision_problem
Status youcans: Optimal
A = 1.0
B = 0.0
C = 0.0
D = 1.0
E = 1.0
Max f(x) = 410.0
"""
```





参考:
https://www.cnblogs.com/youcans/p/14854596.html