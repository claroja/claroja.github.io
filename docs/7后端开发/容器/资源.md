## Namespace

​    Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现**多套环境的资源隔离**或者**多租户的资源隔离**。

​    默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的"组"，以方便不同的组的资源进行隔离使用和管理。

​    可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。


![alt text](资源/namespace.png)



```sh
kubectl create ns dev # 增
kubectl delete ns dev # 删
kubectl get ns # 查
```

## Pod

Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。

Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。

![alt text](资源/pod.png)

```sh
kubectl get pod -n kube-system # 查看pod
kubectl run nginx --image=nginx:1.17.1 --port=80 --namespace dev # 创建p
kubectl describe pod nginx-5ff7956ff6-fg2db -n dev  # 查看pod具体信息
kubectl delete pod nginx-5ff7956ff6-fg2db -n dev  # 删除pod，但pod控制器会重新生成新的， 所以要删除pod控制器， 看下面两行代码
kubectl get deploy -n  dev # 查看pod控制地
kubectl delete deploy nginx -n dev # 市场南湖pod控制器

```

## Label

Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。

Label的特点：

- 一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等
- 一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去

可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。

一些常用的Label 示例如下：

- 版本标签："version":"release", "version":"stable"......
- 环境标签："environment":"dev"，"environment":"test"，"environment":"pro"
- 架构标签："tier":"frontend"，"tier":"backend"

标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，当前有两种Label Selector：

- 基于等式的Label Selector

  name = slave: 选择所有包含Label中key="name"且value="slave"的对象

  env != production: 选择所有包括Label中的key="env"且value不等于"production"的对象

- 基于集合的Label Selector

  name in (master, slave): 选择所有包含Label中的key="name"且value="master"或"slave"的对象

  name not in (frontend): 选择所有包含Label中的key="name"且value不等于"frontend"的对象

标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号","进行分隔即可。例如：

​- name=slave，env!=production

​- name not in (frontend)，env!=production


```sh
kubectl label pod nginx-pod version=1.0 -n dev  # 为pod资源打标签
kubectl label pod nginx-pod version=2.0 -n dev --overwrite  # 为pod资源更新标签
kubectl get pod nginx-pod  -n dev --show-labels  # 查看标签
kubectl get pod -n dev -l version=2.0  --show-labels # 根据标签筛选
kubectl label pod nginx-pod version- -n dev  # 删除标签
```


## Deployment


​在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。

在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。

![alt text](资源/deployment.png)


```sh
# 命令格式: kubectl run deployment名称  [参数] 
# --image  指定pod的镜像
# --port   指定端口
# --replicas  指定创建pod数量
# --namespace  指定namespace

kubectl run nginx --image=nginx:1.17.1 --port=80 --replicas=3 -n dev
kubectl get pods -n dev  # 查看创建的Pod
kubectl get deploy -n dev  # 查看deployment的信息
kubectl get deploy -n dev -o wide  # UP-TO-DATE：成功升级的副本数量， AVAILABLE：可用副本的数量
kubectl describe deploy nginx -n dev  # 查看deployment的详细信息
kubectl delete deploy nginx -n dev  # 删除 
```


##  Service

通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。

虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：

- Pod IP 会随着Pod的重建产生变化
- Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问

这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。

service可以看作是一组同类Pod**对外的访问接口**。借助Service，应用可以方便地实现服务发现和负载均衡。

![alt text](资源/service.png)

1. 操作一：创建集群内部可访问的Service

    ```sh
    kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev # 暴露Service
    kubectl get svc svc-nginx -n dev -o wide  # 查看service， CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的
    ```

2. 操作二：创建集群外部也可访问的Service


```sh
kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev  # 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问， 如果需要创建外部也可以访问的Service，需要修改type为NodePort
kubectl get svc  svc-nginx-1  -n dev -o wide  # 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）
kubectl delete svc svc-nginx-1 -n dev  # 删除Service
```
















































