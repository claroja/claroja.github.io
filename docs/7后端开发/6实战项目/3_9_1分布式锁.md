# 分布式锁

在实际下单场景中， 会由于网络波动， 出现同一时刻收到多个请求数据包， 导致并发问题； 由于客户可以在不同终端操作下单，如果同时下单，也可能会出现并发问题，在微服务分布式运行情况下， 需要采用分布式锁来解决并发所产生的问题。

## Redis分布式锁正确用法

这里我们采用Redis作为分布式锁实现， Redis的正确加锁方式： 

```java
String result = jedis.set(lockKey, clientId, "NX", "PX", expireTime);

if ("OK".equals(result)) {
    return true;
}
return false;


```

- 第一参数lockKey， 是分布式锁标识， 需要加锁的对象；
- 第二参数clientId，是锁对应存储的值，这里放置的是请求标识ID，根据业务需要设定存储值；
- 第三个参数填写的是NX，意思是如果KEY不存在， 则进行SET操作， 若存在， 不作处理；
- 第四个参数是”PX"，代表要追加设定KEY的超时时间；
- 第五个参数是设定具体的超时时间；

加锁要保障互斥性， 如果锁存在， 其他线程就不能加锁成功；其次要设定超时时间， 即便锁拥有着产生系统异常而没有解锁， 到过期时间之后也能自动解锁， 不会出现僵尸锁。加锁和设定锁的超时时间都是在一个方法里面完成， Redis是单线程， 能够保障原子性操作。

错误加锁方式：

```java
Long result = jedis.setnx(lockKey, clientId);
if (result == 1) {
    // 如果程序崩溃，无法设置过期时间，资源将一直无法释放
    jedis.expire(lockKey, expireTime);
}
```

这里是分成两步操作， 如果过程中， 程序出现崩溃， 则KEY会一直常驻Redis，不能得到有效释放。




##3.2  分布式锁方案(Spring Integration Redis)

Spring Integration 对Redis分布式锁处理做了封装， 它是一个轻量级的ESB（企业服务总线）， 提供了基于Spring的EIP(Enterprise Integration Patterns, 企业集成模式)的实现。采用Spring Integration 作为分布式锁实现方案， 是因为Spring较高抽象设计能力， 可以支持接入众多存储组件作为分布式锁的实现方案，比如GemFire（高性能的分布式内存对象缓存系统）、JDBC数据库、Redis、Zookeeper，如果要替换其他存储组件， 不用再修改代码， 更改配置即可。

用法：

```java

// 根据账户ID进行加锁
Lock lock = redisLockRegistry.obtain("accountId");
boolean isLock = lock.tryLock(5, TimeUnit.SECONDS);

//处理业务逻辑
...

// 解锁
lock.unlock();
```

使用比较简单，在业务逻辑处理之前， 通过传递指定的Key进行加锁， 最后再进行解锁。

redisLockRegistry内部是做了一层缓存， 通过ConcurrentHashMap保存锁信息，调用tryLock方法会在Redis生成锁的缓存信息。



##  资金服务集成分布式锁

资金服务的加锁处理逻辑

在使用分布式锁之前， 需要考虑以下问题， 锁的粒度是到什么？ 如果没有拿到锁， 该如何处理？ 

锁的粒度， 我们控制在账户级别， 根据账户ID进行加锁， 确保同一时刻， 每个账户只有一个请求在处理；

如果不能即刻拿到锁， 会先等待， 达到指定时间， 还不能拿到锁， 再封装异常返回给客户端。











