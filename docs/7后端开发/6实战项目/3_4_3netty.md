# netty

## 讲解

### Netty简介

Netty是由JBOSS提供的一个java开源框架。是一个基于NIO的客户、服务器端编程框架，用以快速开发高性能、高可靠性的网络服务器和客户端程序。

### TCP/IP五层模型

![](金融项目/NETTY_TCP.png)

什么是Socket套接字编程接口?   是指在 TCP/IP 协议族中，应用层进入传输层的接口, 用套接字编写使用 TCP或UDP 的网络应用程序。

### 什么是NIO?

- 单线程阻塞模式
  
    ![](金融项目/NETTY_BIO.png)

- NIO模型

    ![](金融项目/NETTY_NIO.png)

NIO模型中的Selector是Java的非阻塞I/O实现的关键，它使用了事件通知API以确定在一组非阻塞套接字中有哪些已经就绪能够进行I/O相关的操作。因为可以在任何的时间检查任意的读操作或者写操作的完成状态，一个单一的线程便可以处理多个并发的连接。

### Netty特点

JDK 原生也有一套网络应用程序 API，但使用繁杂，不够完善，需要消耗开发者较多精力去完善整个NIO场景。Netty对JDK的API进行封装，解决上述主要问题， 主要特点：

- 设计优雅

    用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 3.1 版本起）。

- 高性能，吞吐量更高，使用方便

    延迟更低；减少资源消耗；最小化不必要的内存复制。详细记录的 Javadoc，用户指南和示例， 没有其他过多依赖。

- 安全，社区活跃，不断更新

    社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。

### Netty功能设计

![](金融项目/netty_design.jpg)

Netty 功能特性如下：

- 传输服务，支持 BIO 和 NIO。
- 容器集成，支持 OSGI(开放服务网关协议)、JBossMC、Spring、Guice 容器。
- 协议支持，HTTP、Protobuf、二进制、文本、WebSocket 等一系列常见协议都支持。还支持通过实行编码解码逻辑来实现自定义协议。
- Core 核心，可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象。

### I/O复用模型

![](金融项目/netty_non_io.jpg)

Netty 的非阻塞 I/O 的实现关键是基于 I/O 复用模型

![](金融项目/netty_io_multi.jpg)

在 I/O 复用模型中，会用到 Select，这个函数也会使进程阻塞，但是和阻塞 I/O 所不同的是这两个函数可以同时对多个 I/O 操作。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。

### 引进Buffer

传统的 I/O 是面向字节流或字符流的，以流式的方式顺序地从一个 Stream 中读取一个或多个字节, 因此也就不能随意改变读取指针的位置。

在 NIO 中，抛弃了传统的 I/O 流，而是引入了 Channel 和 Buffer 的概念。ByteBuffer是除了Selector、Channel之外的另一个很重要的组件；在 NIO 中，只能从 Channel 中读取数据到 Buffer 中或将数据从 Buffer 中写入到 Channel。基于 Buffer 操作不像传统 IO 的顺序操作，NIO 中可以随意地读取任意位置的数据。

### 事件驱动模型

何时创建连接？何时读取数据，什么时候开始对数据包做解码与编码？如何触发调用业务处理逻辑？ 各环节如何协调处理， 是采用轮询方式还是事件驱动方式更为高效？

事件驱动模型流程图

![](金融项目/netty_nio_event.jpg)

主要包含4个组件：

- 事件队列（event queue）：接收事件的入口，存储待处理事件。
- 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元。
- 事件通道（event channel）：分发器与处理器之间的联系渠道。
- 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作。

事件驱动的优点：

- 可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑。
- 高性能，基于队列暂存事件，能方便并行异步处理事件。

### Reactor 线程模型

![](金融项目/netty_reactor.jpg)

Reactor是一个执行 while (true) { selector.select(); …} 循环的线程，会源源不断的产生新的事件，类似反应堆。 Reactor模型是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。

Reactor 模型中有 2 个关键组成：

- Reactor，Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人。
- Handlers，处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际职员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。

### Netty 工作线程模型

![](金融项目/netty_thread_model.jpg)

Netty 主要基于主从 Reactors 多线程模型（如下图）做了一定的修改，其中主从 Reactor 多线程模型有多个 Reactor：

- MainReactor 负责客户端的连接请求，并将请求转交给 SubReactor。
- SubReactor 负责相应通道的 IO 读写请求。
- 非 IO 请求（具体逻辑处理）的任务则会直接写入队列，等待 worker threads 进行处理。

## 参考

- <https://developer.aliyun.com/article/1055214>
- <https://juejin.cn/post/6844903704668160008>
