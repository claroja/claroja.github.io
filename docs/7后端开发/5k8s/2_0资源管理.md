# 资源管理

## 资源管理介绍

在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。

kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。

kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在`Pod`中，而kubernetes一般也不会直接管理Pod，而是通过`Pod控制器`来管理Pod的。

Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了`Service`资源实现这个功能。

当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种`存储`系统。

![alt text](资源管理/kubernetes资源管理.png)

学习kubernetes的核心，就是学习如何对集群上的`Pod、Pod控制器、Service、存储`等各种资源进行操作

## 资源管理方式

命令去操作kubernetes资源: `kubectl run nginx-pod --image=nginx:1.17.1 --port=80`

​kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：

`kubectl [command] [type] [name] [flags]`

- `comand`：指定要对资源执行的操作，例如create、get、delete
- `type`：指定资源类型，比如deployment、pod、service
- `name`：指定资源的名称，名称大小写敏感
- `flags`：指定额外的可选参数

```powershell
# 查看所有pod
kubectl get pod 
# 查看某个pod
kubectl get pod pod_name
# 查看某个pod,以yaml格式展示结果
kubectl get pod pod_name -o yaml
```
## Pod

Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。

Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。

![alt text](资源管理/pod.png)

```sh
kubectl get pod -n kube-system # 查看pod
kubectl run nginx --image=nginx:1.17.1 --port=80 --namespace dev # 创建p
kubectl describe pod nginx-5ff7956ff6-fg2db -n dev  # 查看pod具体信息
kubectl delete pod nginx-5ff7956ff6-fg2db -n dev  # 删除pod，但pod控制器会重新生成新的， 所以要删除pod控制器， 看下面两行代码
kubectl get deploy -n  dev # 查看pod控制地
kubectl delete deploy nginx -n dev # 市场南湖pod控制器

```

## Namespace

​Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现多套`环境`的资源隔离或者`多租户`的资源隔离。

​默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的"组"，以方便不同的组的资源进行隔离使用和管理。

​可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。

![alt text](资源管理/namespace.png)

```sh
kubectl create ns dev # 增
kubectl delete ns dev # 删
kubectl get ns # 查
```

## Label

Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。

Label的特点：

- 一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等
- 一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去

可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。

一些常用的Label示例如下：

- 版本标签："version":"release", "version":"stable"......
- 环境标签："environment":"dev"，"environment":"test"，"environment":"pro"
- 架构标签："tier":"frontend"，"tier":"backend"

标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，当前有两种Label Selector：

- 基于等式的Label Selector

  name = slave: 选择所有包含Label中key="name"且value="slave"的对象

  env != production: 选择所有包括Label中的key="env"且value不等于"production"的对象

- 基于集合的Label Selector

  name in (master, slave): 选择所有包含Label中的key="name"且value="master"或"slave"的对象

  name not in (frontend): 选择所有包含Label中的key="name"且value不等于"frontend"的对象

标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号","进行分隔即可。例如：

​- name=slave，env!=production

​- name not in (frontend)，env!=production


```sh
kubectl label pod nginx-pod version=1.0 -n dev  # 为pod资源打标签
kubectl label pod nginx-pod version=2.0 -n dev --overwrite  # 为pod资源更新标签
kubectl get pod nginx-pod  -n dev --show-labels  # 查看标签
kubectl get pod -n dev -l version=2.0  --show-labels # 根据标签筛选
kubectl label pod nginx-pod version- -n dev  # 删除标签
```

## pod管理器

​在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。

在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。

![alt text](资源管理/deployment.png)


```sh
# 命令格式: kubectl run deployment名称  [参数] 
# --image  指定pod的镜像
# --port   指定端口
# --replicas  指定创建pod数量
# --namespace  指定namespace

kubectl run nginx --image=nginx:1.17.1 --port=80 --replicas=3 -n dev
kubectl get pods -n dev  # 查看创建的Pod
kubectl get deploy -n dev  # 查看deployment的信息
kubectl get deploy -n dev -o wide  # UP-TO-DATE：成功升级的副本数量， AVAILABLE：可用副本的数量
kubectl describe deploy nginx -n dev  # 查看deployment的详细信息
kubectl delete deploy nginx -n dev  # 删除 
```


## Service

通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。

虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：

- Pod IP 会随着Pod的重建产生变化
- Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问

这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。

service可以看作是一组同类Pod`对外`的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。

![alt text](资源管理/service.png)

1. 操作一：创建集群内部可访问的Service

    ```sh
    kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev # 暴露Service
    kubectl get svc svc-nginx -n dev -o wide  # 查看service， CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的
    ```

2. 操作二：创建集群外部也可访问的Service


```sh
kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev  # 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问， 如果需要创建外部也可以访问的Service，需要修改type为NodePort
kubectl get svc  svc-nginx-1  -n dev -o wide  # 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）
kubectl delete svc svc-nginx-1 -n dev  # 删除Service
```
