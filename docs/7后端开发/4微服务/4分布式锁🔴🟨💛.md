# 分布式锁

## 最佳实践

### 考察点

- 分布式锁应具有的特性: `性可重锁塞`

    - `高性能`的获取锁与释放锁
    - `高可用`的获取锁与释放锁
    - `可重入`特性
    - `锁失效`机制，防止死锁
    - `非阻塞`锁特性，即没有获取到锁将直接返回获取锁失败
- 分布式锁的实现方式: `数据库`, `ZooKeeper`, `Redis`
- 数据库实现分布式锁的步骤
    1. 在数据库中创建一个表，表中包含`锁`字段，并在方法名字段上创建`唯一`索引。
    2. 想要执行某个方法，首先需要将这个方法名`插入`表中
        - `成功`则获取锁，此种方式就是建立在数据库唯一索引的特性基础上的。
        - `失败`, 则等待
    3. 执行完成后`删除`对应的行数据释放锁
- ZooKeeper实现分布式锁的步骤

    1. 首先创建Znode节点, 表示一把分布式锁, 这里假设为`/lock`.

    2. 如果某个客户端需要占用锁，
        1. 在`/lock`节点下创建一个`临时有序`的子节点。

        所有临时有序子节点，尽量共用一个有意义的子节点前缀。比如，第一次抢锁对应的子节点为`/lock/000000000`，第二次抢锁对应的子节点为`/lock/000000001`，以此类推。

        2. 客户端创建子节点后，需要进行判断：自己创建的子节点，是否为当前子节点列表中序号最小的子节点。
        - 如果是，则认为加锁成功；
        - 如果不是，则监听`前一个`Znode子节点变更消息，等待前一个节点释放锁。

    3. 获取锁后，开始处理业务流程。完成业务流程后，`删除`自己的对应的子节点，完成释放锁的工作，后继节点捕获到节点变更通知，获得分布式锁。

- Redis实现分布式锁

    - 加锁命令：`set` lock_key `ClientID` `NX` `PX 5000`
    - 解锁命令：`del` lock_key

## 分布式锁基本概念

在我们进行单机应用开发涉及并发同步的时候，我们往往采用synchronized或者ReentrantLock的方式来解决多线程间的代码同步问题。但是当我们的应用是在分布式集群工作的情况下，那么就需要一种更加高级的锁机制，来处理种跨机器的进程之间的数据同步问题，这就是分布式锁。因为synchronized、ReentrantLock只是jvm级别的加锁，没有办法控制其他jvm。也就是上面两个tomcat实例还是可以出现并发执行的情况。要解决分布式环境下的并发问题，则必须使用分布式锁。

一个资源在同一时间只能被一个`机器`的一个`线程`执行

分布式锁的实现方式有多种，例如：数据库实现方式、ZooKeeper实现方式、Redis实现方式等。

## 分布式锁应具有的特性

- `高可用`的获取锁与释放锁
- `高性能`的获取锁与释放锁
- `可重入`特性
- `锁失效`机制，防止死锁
- `非阻塞`锁特性，即没有获取到锁将直接返回获取锁失败

## 分布式锁实现方案

### 数据库实现分布式锁

1. 在数据库中创建一个表，表中包含`锁`字段，并在方法名字段上创建`唯一`索引。
2. 想要执行某个方法，首先需要将这个方法名`插入`表中
    - `成功`则获取锁，此种方式就是建立在数据库唯一索引的特性基础上的。
    - `失败`, 则等待
3. 执行完成后`删除`对应的行数据释放锁

表结构如下：

| Field      | Type        | Null | Key | Default | Extra          |
|------------|-------------|------|-----|---------|----------------|
| id         | int(11)     | NO   | PRI | NULL    | auto_increment |
| methodName | varchar(255)| YES  | UNI | NULL    |                |

注意，虽然使用数据库方式可以实现分布式锁，但是这种实现方式还存在如下一些问题：

- 因为是基于数据库实现的，数据库的`可用性`和`性能`将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；
- 不具备`可重入`的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；
- 没有`锁失效`机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；
- 不具备`非阻塞锁`特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。

## ZooKeeper实现分布式锁

Zookeeper的数据存储结构就像一棵树，这棵树由节点组成，这种节点叫做Znode。

#### Zookeeper中节点分为4种类型

1. `持久节点 （PERSISTENT）`：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点`依旧存在`
2. `持久顺序节点（PERSISTENT_SEQUENTIAL）`：所谓顺序节点，就是在创建节点时，Zookeeper根据`创建的时间`顺序给该节点名称进行编号
3. `临时节点（EPHEMERAL）`：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被`删除`
4. `临时顺序节点（EPHEMERAL_SEQUENTIAL）`：顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的`时间`顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被`删除`

#### Zookeeper的监听机制

每个节点可以监听指定节点的变化.

#### 使用ZooKeeper实现分布式锁的算法的步骤

1. 首先创建Znode节点, 表示一把分布式锁, 这里假设为`/lock`.

2. 如果某个客户端需要占用锁，
    1. 在`/lock`节点下创建一个`临时有序`的子节点。

    所有临时有序子节点，尽量共用一个有意义的子节点前缀。比如，第一次抢锁对应的子节点为`/lock/000000000`，第二次抢锁对应的子节点为`/lock/000000001`，以此类推。

    2. 客户端创建子节点后，需要进行判断：自己创建的子节点，是否为当前子节点列表中序号最小的子节点。
    - 如果是，则认为加锁成功；
    - 如果不是，则监听`前一个`Znode子节点变更消息，等待前一个节点释放锁。

3. 获取锁后，开始处理业务流程。完成业务流程后，`删除`自己的对应的子节点，完成释放锁的工作，后继节点捕获到节点变更通知，获得分布式锁。

✨ZooKeeper的节点监听机制，可以保障占有锁的传递有序而且高效, 当一个节点挂掉，只有它后面的那一个节点才做出反应, 不影响其他节点.
✨由于网络异常或者其他原因，集群中占用锁的客户端失联时，锁能够被有效释放。这个临时Znode也将自动删除。排在它后面的那个节点，也能收到删除事件，从而获得锁。

Apache Curator是一个比较完善的ZooKeeper客户端框架，通过封装的一套高级API 简化了ZooKeeper的操作，其中就包括分布式锁的实现。

### Redis实现分布式锁

redis实现分布式锁比较简单，就是调用redis的set命令设置值，能够设置成功则表示加锁成功，即获得锁，通过调用del命令来删除设置的键值，即释放锁。

- 加锁命令：set lock_key `ClientID` `NX` `PX 5000`
- 解锁命令：del lock_key

参数解释:

1. value的值为`ClientID`, 保证了加锁和解锁必须是同一个客户端，所以在加锁时可以设置当前线程id，在释放锁时判断是否为当前线程加的锁，如果是再释放锁即可。防止不同的客户端释放其他客户端的锁.
2. 参数: `NX`, 保证了唯一性, 如果锁存在则插入失败
3. 参数: `PX 5000`, 设置过期时间, 防止死锁

### Redisson

Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。

Redisson已经内置提供了基于Redis的分布式锁实现，此种方式是我们推荐的分布式锁使用方式。

## 参考

- <https://zhuanlan.zhihu.com/p/639756647>
