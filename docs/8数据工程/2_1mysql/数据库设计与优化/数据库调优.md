## 数据库调优

### 调优简介

MySQL是目前使用最多的开源数据库，但是MySQL数据库的默认设置性能并非最优，特别在生产环境当中， 如果不去合理优化，不能发挥最佳性能，  甚至会产生各种各样的问题。 因此数据库必须进行必要的调整与优化。

那么如何进行调优？ 有哪些方法？ 每个系统环境配置不一样， 如何去设置？ 线上出现的慢查询， 又如何去定位分析？ 带着这些问题， 我们逐一去分析解决。

### 如何调优

1. 影响数据库性能原因：


    联机分析处理（OLAP,On-line Analytical Processing），数据量大，DML少。
    联机事务处理（OLTP,On-line Transaction Processing），数据量少，DML频繁。

    |维度|OLTP|OLAP|
    |----------|-------------------------------|-------------------------------|
    |用户|操作人员,低层管理人员|决策人员,高级管理人员|
    |功能|日常操作处理|分析决策|
    |DB设计|面向应用|面向主题|
    |数据|当前的,最新的细节的,二维的分立的|历史的,聚集的,多维的集成的,统一的|
    |存取|读/写数十条记录|读上百万条记录|
    |工作单位|简单的事务|复杂的查询|
    |用户数|上千个|上百个|
    |DB大小|100MB-GB|100GB-TB|

2. 调优方法

   - 业务设计的合理性

     业务设计并不是满足一切业务需求， 在碰到性能瓶颈之处， 要学会权衡取舍， 比如一些业务数据报表， 不需要很强的实时性， 那么就不用直接查询核心数据表增加压力， 采用预生成方式， 这样既满足业务要求， 又能保持核心数据表的操作性能。

   - 增加索引

     索引可以极大优化查询性能， 索引包含主键索引（PRIMAY KEY）、唯一索引（UNIQUE）、常规索引（INDEX）和全文索引（FULLTEXT）。

     索引底层可以采用Btree索引和Hash索引：

     - *B-TREE*， B树是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树为系统大块数据的读写操作做了优化。B树可以减少定位记录时所经历的中间过程，从而加快存取速度。

        B-TREE特征：

        B-TREE通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离都相同。

        B-TREE索引能够加快访问数据的速度，是因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始搜索。

        B-TREE对索引列是顺序组织存储的，所以很适合查找范围数据。

     - Hash索引：

        Hash是采用哈希算法计算，得到哈希值，排序在哈希数组上。所以Hash索引可以一次定位，其效率很高，而Btree索引需要经过多次的磁盘IO，但是Hash索引也存在缺点：

        - 因为Hash索引比较的是经过Hash计算的值，所以只能进行等式比较，不能用于范围查询

        - 由于哈希值是按照顺序排列的，但是哈希值映射的真正数据在哈希表中就不一定按照顺序排列，所以无法利用Hash索引来加速任何排序操作

        - 当哈希值大量重复且数据量非常大时，其检索效率并没有Btree索引高的。

        注意： 索引并不是一味的增加， 一般一张表索引的数量控制4-5个之内。  

   - 分库分表

        分库可以分解数据压力， 采用集群方式，或业务拆分， 从根本上提升整个系统的I/O吞吐能力。

        分表在于单表集中压力的化解， 一般可通过垂直/水平方式进行拆分。分表一般都是单维度拆分， 利用某个字段取模或者根据时间字段进行拆分； 对于多维度的拆分，可采用基因法， 基因法是根据某个字段的特征， 再融入到其他维度字段中，利用基因进行数据定位。 例如， 通过uid分库，分为8个库，采用uid%8的方式进行路由，此时是由uid的最后3bit来决定这行User数据具体落到哪个库上，那么这3bit可以看为分库基因。

        分表也并不是万能， 比如关联查询、分页查询、以及数据路由带来的开销。

   - 读写分离

        读写分离，基本的原理是让主数据库处理事务性的增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。

        在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。
        
        因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。

   - SQL语句调优

        通过SQL语句的调整来优化响应时间。常见的SQL语句优化点包：

        - 调整Where字句中的连接顺序，一般采用自下而上的顺序解析where字句。
        - 尽量将多条SQL语句压缩到一句， 减少网络开销， IO执行开销。
        - 用where语句替换HAVING语句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤。
        - 使用表的别名，减少属性解析的时间。
        - 在in和exists中通常情况下使用EXISTS，因为in不走索引。
        - 用union all替换union，union会尝试进行合并，然后在输出最终结果前进行排序。

   - mysql配置优化

        - 连接数
        - 缓存
        - 吞吐量
        - IO线程
        - 闲置连接回收

   - 其他优化

     - 索引重建优化
     - 磁盘碎片优化
     - 数据库新特性评估使用，版本升级。

### 执行计划分析

1. 什么是执行计划

   执行计划就是分析执行Sql语句的过程,包括Sql查询的顺序、是否使用索引、以及使用的索引信息等内容。

   一个执行计划由若干基本操作组成. 例如, 遍历整张表, 利用索引, 执行一个嵌套循环或Hash连接等等。

2. explain关键字与输出项说明

   要生成执行计划， 在相应的语句之前加上explain关键字：

   ```sql
   explain select ...
   ```

    explain只是预估， 并非实际执行。

   EXPLAIN输出项

   | Column        |   JSON Name   |                           Meaning                            |
   | ------------- | :-----------: | :----------------------------------------------------------: |
   | id            |   select_id   |              The SELECT identifier(选择标识符)               |
   | select_type   |     None      |                  The SELECT type (查询类型)                  |
   | table         |  table_name   |        The table for the output row (输出结果的表名)         |
   | partitions    |  partitions   |           The matching partitions(匹配的分区信息)            |
   | type          |  access_type  |                The join type(表示的连接类型)                 |
   | possible_keys | possible_keys |      The possible indexes to choose (可能使用到的索引)       |
   | key           |      key      |          The index actually chosen(实际使用的索引)           |
   | key_len       |  key_length   |         The length of the chosen key(索引字段的长度)         |
   | ref           |      ref      | The columns compared to the index(表的连接匹配条件, 哪些列或常量被用于查找索引列上的值) |
   | rows          |     rows      |       Estimate of rows to be examined(扫描估算的行数)        |
   | filtered      |   filtered    | Percentage of rows filtered by table condition(按条件过滤的行百分比) |
   | Extra         |     None      |      Additional information(执行计划的情况的描述和说明)      |

   注意：在5.7以前的版本中，想要显示partitions需要使用explain partitions命令；想要显示filtered需要使用explain extended命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。

3. 通过实际SQL来解读执行计划信息

    通过脚本，创建好用于SQL执行计划的数据。

    下面分析两条SQL语句的执行计划:

    第一条语句是要查询用户所关联的角色信息， USER_ACCOUNT为唯一索引。

    ```sql

    EXPLAIN SELECT
    u.id,

    u.USER_ACCOUNT,
    r.ROLE_NAME
    FROM
    s_authority_user u
    LEFT JOIN s_authority_user_role ur ON u.id = ur.USER_ID
    LEFT JOIN s_authority_role r ON ur.role_id = r.id
    WHERE
    u.USER_ACCOUNT = 'admin'

    ```



    第二条语句是一个多SQL查询:

    ```sql
        EXPLAIN SELECT
        u1.* 
        FROM
        s_authority_user u1 UNION
        SELECT
        u2.* 
        FROM
        s_authority_user u2
    ```

    下面， 详细分析执行计划各字段含义：

- id属性

     id为SELECT的标识符， 如果这一行表示其他行的union结果，这个值可以为空。在这种情况下，table列会显示为形如`<union M,N>`，表示它是id为M和N的查询行的联合结果。例如第二条SQL的查询。

    - id相同执行顺序由上至下。
    - id不同，id值越大优先级越高，越先被执行。
    - id为null时表示一个结果集，不需要使用它查询，常出现在包含`union`等查询语句中。

- select_type属性

     常见的属性值

     | id   | select_type  | description                                                  |
     | ---- | ------------ | ------------------------------------------------------------ |
     | 1    | SIMPLE       | 不包含任何子查询或union等查询                                |
     | 2    | PRIMARY      | 包含子查询最外层查询就显示为 `PRIMARY`                       |
     | 3    | SUBQUERY     | 在`select`或 `where`字句中包含的查询<br /> （in匹配不会生效, 要采用等号） |
     | 4    | DERIVED      | `from`字句中包含的查询                                       |
     | 5    | UNION        | 出现在`union`后的查询语句中                                  |
     | 6    | UNION RESULT | 从UNION中获取结果集，例如上面的例子                          |

     除此之外还有， derived：from字句中出现的子查询； materialized：被物化的子查询等， 这些用得相对较少。

- table属性

     显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的`<derived N>`就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的`<union M,N>`，与`<derived N>`类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。

     例如：

     ```sql
     EXPLAIN SELECT
      u.id,
     u.USER_ACCOUNT,
      r.ROLE_NAME 
     FROM
      s_authority_user u
     LEFT JOIN (select USER_ID, role_id from s_authority_user_role group by user_id) ur ON u.id = ur.USER_ID
      LEFT JOIN s_authority_role r ON ur.role_id = r.id 
     WHERE
      u.USER_ACCOUNT = 'admin'
      
     ```

- partitions属性

     该列显示的为分区表命中的分区情况，非分区表该字段为空（null）。

     例如, 创建一个支持分区的表：

     ```sql
     drop table if exists tmp_partitions;
     create table tmp_partitions (
         id int unsigned not null AUTO_INCREMENT,
         name varchar(255),
         PRIMARY KEY (id)
     ) engine = innodb
     partition by key (id) partitions 3;
     ```

- type属性

     表示表查询的连接类型

     | id   | type              | description                            |
     | ---- | ----------------- | -------------------------------------- |
     | 1    | ALL               | 扫描全表数据    |
     | 2    | index             | 遍历索引 |
     | 3    | range             | 索引范围查找 |
     | 4    | index_subquery    | 在子查询中使用 ref                                   |
     | 5    | unique_subquery   | 在子查询中使用 eq_ref |
     | 6    | UNION ref_or_null | 对Null进行索引的优化的 ref |
     | 7    | fulltext | 使用全文索引 |
     | 8   | ref |使用非唯一索引查找数据    |
     | 9   | eq_ref | 在join查询中使用PRIMARY KEY或UNIQUE NOT NULL索引关联 |
     | 10 | const |使用主键或者唯一索引，且匹配的结果只有一条记录    |
     | 11 | system const  | 连接类型的特例，查询的表为系统表 |

    - 性能依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL。
    - index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。按照官方文档的说法。
    - ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见于辅助索引的等值查找； 或者多列主键、唯一索引中，除第一个列之外的列， 作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。
    - range：索引范围扫描，常见于使用 `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()`或者like等运算符的查询中。

- possible_keys属性

     可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 null时就要考虑当前的SQL是否需要优化了。

- key属性

     显示查询使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。

- key_len属性

     索引长度，字符索引长度的计算公式：

     ```txt
     (Character Set：utf8mb4=4,utf8=3,gbk=2,latin1=1) * 列长度 + 1(允许null) + 2(变长列)
     ```

     key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。

- ref属性

     如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func。

- rows属性

     返回估算的结果集数目， 因为explain并非真正执行语句， 所以并非精确值。

- extra属性
     常见的有：

    - Using index: 使用覆盖索引
    - Using where: 使用了where子句来过滤结果集， 表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。
    - Using filesort: 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。
    - Using temporary: 表示使用了临时表存储中间结果

     注意： extra辅助信息中的using filesort和using temporary，这两项非常消耗性能，需要谨慎。
