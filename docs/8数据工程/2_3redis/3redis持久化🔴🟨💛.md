# redis持久化

## 最佳实践


### 考察问

- Redis有两种持久化方案：

    - `()`持久化: 将内存进行快照, 保存到磁盘文件
    - `()`持久化: 保存执行的命令到磁盘文件

- RDB持久化的命令:

    - 执行`()`命令: 主进程执行RDB, 其它所有命令都会被阻塞。只有在数据迁移时可能用到。
    - 执行`()`命令: 开启独立进程完成RDB，主进程可以持续处理用户请求

- RDB的bagsave命令原理

    ![alt text](redis持久化/RDBfork.png)

- 在redis.conf中的save字段配置RDB策略

    - save 60 1000的含义, `()`

- 在redis.conf中的appendfsync配置AOF策略

    |配置项|刷盘时机|可靠性|性能|
    |--|--|--|--|
    |always|同步刷盘|`()`, `()`丢数据|性能`()`|
    |everysec|每秒刷盘|`()`, 丢`()`秒数据|性能`()`|
    |no|操作系统控制|`()`, 可能丢`()`数据`()`高`|


- AOF文件重写: 只记录`()`一次更改

- RDB和AOF的区别


    ||RDB|AOF|
    |--|--|--|
    |持久化方式|定时对整个内存做`()`|记录每一次执行的`()`|
    |数据完整性|不完整，`()`|相对完整，取决于`()`|
    |文件大小|会有压缩，文件体积`()`|记录命令，文件体积很`()`|
    |宕机恢复速度|`()`|`()`|
    |数据恢复优先级|`()`，因为数据完整性不如AOF|`()`，因为数据完整性更高|
    |系统资源占用|`()`，大量CPU和内存消耗|`()`，主要是磁盘IO资源<br>但AOF重写时会占用大量CPU和内存资源|
    |使用场景|可以容忍数分钟的数据丢失，追求更快的`()`速度|对数据的`()`要求较高常见|


### 考察点

- Redis有两种持久化方案：

    - `RDB`持久化: 将内存进行快照, 保存到磁盘文件
    - `AOF`持久化: 保存执行的命令到磁盘文件

- RDB持久化的命令:

    - 执行`save`命令: 主进程执行RDB, 其它所有命令都会被阻塞。只有在数据迁移时可能用到。
    - 执行`bgsave`命令: 开启独立进程完成RDB，主进程可以持续处理用户请求

- RDB的bagsave命令原理

    ![alt text](redis持久化/RDBfork.png)

- 在redis.conf中的save字段配置RDB策略

    - save 60 1000的含义, `60秒内至少执行1000次修改则触发RDB`

- 在redis.conf中的appendfsync配置AOF策略

    |配置项|刷盘时机|可靠性|性能|
    |--|--|--|--|
    |always|同步刷盘|`高`, `几乎不`丢数据|性能`低`|
    |everysec|每秒刷盘|`中`, 丢`1`秒数据|性能`中`|
    |no|操作系统控制|`低`, 可能丢`大量`数据`|性能`高`|


- AOF文件重写: 只记录`最后`一次更改

- RDB和AOF的区别


    ||RDB|AOF|
    |--|--|--|
    |持久化方式|定时对整个内存做`快照`|记录每一次执行的`命令`|
    |数据完整性|不完整，`两次备份之间会丢失`|相对完整，取决于`刷盘策略`|
    |文件大小|会有压缩，文件体积`小`|记录命令，文件体积很`大`|
    |宕机恢复速度|`快`|`慢`|
    |数据恢复优先级|`低`，因为数据完整性不如AOF|`高`，因为数据完整性更高|
    |系统资源占用|`高`，大量CPU和内存消耗|`低`，主要是磁盘IO资源<br>但AOF重写时会占用大量CPU和内存资源|
    |使用场景|可以容忍数分钟的数据丢失，追求更快的`启动`速度|对数据的`完整性`要求较高常见|





## 基础概念

Redis有两种持久化方案：
- `RDB`持久化: 将内存进行快照, 保存到磁盘文件
- `AOF`持久化: 保存执行的命令到磁盘文件


## RDB持久化

RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据`快照`。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。

### RDB持久化命令：

- 执行`save`命令: 主进程执行RDB, 其它所有命令都会被阻塞。只有在数据迁移时可能用到。
- 执行`bgsave`命令: 开启独立进程完成RDB，主进程可以持续处理用户请求

两种自动出发RDB的情景:

- Redis停机时: Redis停机时会执行一次`save`命令，实现RDB持久化。
- 触发RDB条件时: Redis内部有触发RDB的`bgsave`机制，可以在redis.conf文件中找到，格式如下：

    ```properties
    # 900秒内，如果至少有1个key被修改，则执行bgsave ，如果是save "" 则表示禁用RDB
    save 900 1  
    ```

### RDB的bgsave原理

bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。

fork采用的是copy-on-write技术：

- 当主进程执行读操作时，访问共享内存；
- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。

![alt text](redis持久化/RDBfork.png)


## AOF持久化


### AOF原理

AOF全称为Append Only File（追加文件）。Redis处理的每一个`写命令`都会记录在AOF文件，可以看做是命令日志文件。

![alt text](redis持久化/AOF.png)


AOF的命令记录的频率也可以通过redis.conf文件来配：

```properties
# 表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
```

三种策略对比：

|配置项|刷盘时机|可靠性|性能|
|--|--|--|--|
|always|`同步刷盘`|`高, 几乎不丢数据`|`性能低`|
|everysec|`每秒刷盘`|`中, 丢1秒数据`|`性能中`|
|no|`操作系统控制`|`低, 可能丢大量数据`|`性能高`|

### AOF文件重写

因为是记录命令，AOF文件会比RDB文件`大`的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

AOF原本有三个命令，但是`set num 123 和 set num 666`都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。

所以重写命令后，AOF文件内容就是：`set num 666`

Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：

```properties
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
```

## RDB与AOF对比

RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。


||RDB|AOF|
|--|--|--|
|持久化方式|定时对整个内存做`快照`|记录每一次执行的`命令`|
|数据完整性|不完整，`两次备份之间会丢失`|相对完整，取决于`刷盘策略`|
|文件大小|会有压缩，文件体积`小`|记录命令，文件体积很`大`|
|宕机恢复速度|`快`|`慢`|
|数据恢复优先级|`低`，因为数据完整性不如AOF|`高`，因为数据完整性更高|
|系统资源占用|`高`，大量CPU和内存消耗|`低`，主要是磁盘IO资源<br>但AOF重写时会占用大量CPU和内存资源|
|使用场景|可以容忍数分钟的数据丢失，追求`更快的启动速度`|对数据`完整性`要求较高常见|



























