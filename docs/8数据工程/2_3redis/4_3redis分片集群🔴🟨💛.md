# redis分片集群

## 最佳实践


### 考察点


- Redis如何判断某个key应该在哪个实例？

    - 将16384个`插槽`分配到不同的`实例`
    - 根据key的`有效`部分计算`哈希值`，对16384`取余`
    - 余数作为`插槽编号`，寻找插槽所在实例即可

- 如何将同一类数据固定的保存在同一个Redis实例？

    - 这一类数据使用相同的有效部分，例如key都以`{xxx}`为前缀


## 搭建分片集群

主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：

- 海量数据存储问题

- 高并发写的问题

使用分片集群可以解决上述问题，如图:

![alt text](redis分片集群/redis分片集群结构.png)


分片集群特征：

- 集群中有多个master，每个master保存不同数据
- 每个master都可以有多个slave节点
- master之间通过ping监测彼此健康状态
- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点



## 散列插槽

### 插槽原理

Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上. 例如有三个master节点, 则会均分:

1. master1: (0-5460)共5461个
2. master2: (5461-10922)共5462个
3. master3: (10923-16383)共5461个

数据key不是与节点绑定，而是与`插槽`绑定。redis会根据key的有效部分计算插槽值，分两种情况：

- key中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分
- key中不包含“{}”，整个key都是有效部分

例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。

1. 在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。
2. 到了7003后，执行`get num`时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点



## 集群伸缩

需求：向集群中添加一个新的master节点，并向其中存储 num = 10

- 启动一个新的redis实例，端口为7004
- 添加7004到之前的集群，并作为一个master节点
- 给7004节点分配插槽，使得num这个key可以存储到7004实例

这里需要两个新的功能：

- 添加一个节点到集群中
- 将部分插槽分配到新插槽


## 故障转移

集群中7001、7002、7003都是master，我们计划让7002宕机。


1. 首先是该实例与其它实例失去连接
2. 然后是疑似宕机：
3. 最后是确定下线，自动提升一个slave为新的master：
4. 当7002再次启动，就会变为一个slave节点了：


### 手动故障转移

利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：

![alt text](redis分片集群/redis手动故障转移.png)



这种failover命令可以指定三种模式：

- 缺省：默认的流程，如图1~6歩
- force：省略了对offset的一致性校验
- takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见









